[{"title":"为什么是Astro","url":"/article/为什么是Astro","content":"为什么是Astro - Astro 是最适合构建像博客、营销网站、电子商务网站这样的以内容驱动的网站的 Web 框架。了解为什么 Astro 可能是你下一个网站的好选择。Astro 是最适合构建像博客、营销网站、电子商务网站这样的以内容驱动的网站的 Web 框架。Astro 以开创了一种新的前端架构而闻名，与其他框架相比它减少了 JavaScript 的开销和复杂性。如果你需要一个加载速度快、具有良好 SEO 的网站，那么 Astro 就是你的选择。功能Astro 是一个集多功能于一体的 Web 框架。它内置包含了你构建网站所需的一切。还有数百个不同的集成和 API 钩子可根据你的具体用例和需求定制你的项目。一些亮点包括：群岛：一种基于组件的针对内容驱动的网站进行优化的 Web 架构。UI 无关：支持 React、Preact、Svelte、Vue、Solid、Lit、HTMX、Web 组件等等。服务器优先：将沉重的渲染移出访问者的设备。默认无 JS：让客户端更少的执行 JS ，以提升网站速度。内容集合：为你的 Markdown 内容，提供组织、校验并保证 TypeScript 类型安全。可定制：Tailwind、MDX 和数百个集成可供选择。设计原则以下的五个核心设计原则有助于解释我们为什么做了 Astro，它需要解决的问题以及为什么 Astro 可能是你的项目或团队的最佳选择。Astro 是…内容驱动：Astro 专为展示你的内容而设计。服务器渲染：网站在服务器上渲染 HTML 时运行速度更快。默认快速：在 Astro 中应当不可能做出缓慢的网站。易于使用：你不需要是一个专家即可使用 Astro 做点什么。以开发者为中心：你应该拥有成功所需的资源。内容驱动Astro 专为构建内容丰富的网站而设计。这包括大多数营销网站、出版网站、文档网站、博客、个人作品集、着陆页、社区网站和电子商务网站。如果你有内容要展示，它需要快速地到达你的读者。相比之下，大多数现代 Web 框架都是为构建 Web 应用程序而设计的。这些框架擅长于在浏览器中构建复杂的、类似应用程序的体验：登录后的管理仪表板、收件箱、社交网络、待办事项列表，甚至是像 Figma 和 Ping 这样的类原生应用程序。然而随着复杂性的增加，它们在提供内容时可能会遇到性能问题。Astro 从它最初作为静态网站生成器的开始就专注于内容，使得 Astro 可以合理地扩展到性能强大的动态 Web 应用程序，同时仍然尊重你的内容和你的受众。Astro 对内容的独特关注让 Astro 能够做出取舍并提供无与伦比的在其他框架中实现起来不合理的性能功能。服务器渲染Astro 尽可能多地使用服务器渲染而不是在浏览器中的客户端渲染。这与传统的服务器端框架 — 像 PHP、WordPress、Laravel、Ruby on Rails 等 — 使用了几十年的方法相同。但你不需要学习第二种服务端语言来解锁它。使用 Astro，一切仍然只是 HTML、CSS 和 JavaScript（或 TypeScript，如果你乐意的话）。这种方法与其他现代 JavaScript Web 框架形成鲜明对比，如 Next.js、SvelteKit、Nuxt、Remix 等。这些框架是为客户端渲染整个网站而制作的，提供服务器端渲染主要是为了解决性能问题。这种方法被称为单页应用程序（SPA），对比 Astro 的多页应用程序（MPA）。SPA 模式有它的优势。然而，这些都是以牺牲额外的复杂性和性能权衡为代价的。这些取舍损害了页面性能 — 比如可交互时间（TTI）等关键指标 — 对于以内容为中心的网站没有多大意义，而这种网站的首次加载性能至关重要。Astro 的服务器优先方法使你可以在且仅在必要的时候选择加入客户端渲染。你可以选择添加在客户端运行的 UI 框架组件。你可以利用 Astro 的视图过渡路由来更精细地控制选定页面的过渡和动画。Astro 的服务器优先渲染，无论是预渲染还是按需渲染，都提供了可以增强和扩展的高性能默认值。默认快速好的性能总是重要的，但它对于那些成功取决于展示你的内容的网站来说尤其重要。事实已经充分证明糟糕的性能表现会让你失去参与度、转化率和金钱。例如：每快 100ms → 转化率增加 1% (Mobify, 收入 +$380,000/年)每快 50% → 销售额增加 12% (AutoAnything)每快 20% → 转换率增加 10% (Furniture Village)每快 40% → 注册率增加 15% (Pinterest)每快 850ms → 转化率增加 7% (COOK)每慢 1 秒 → 减少 10% 的用户 (BBC)在许多 Web 框架中，很容易在开发过程中构建一个看起来很棒的网站，但在部署后加载速度非常慢。JavaScript 通常是罪魁祸首，因为用户的手机和低功耗设备很少能与开发者的电脑速度相匹配。Astro 的魔力在于它如何将上述两个价值 — 以内容为中心和服务器优先的架构 — 相结合，做出权衡并提供其他框架无法实现的功能。结果是每个网站都开箱即有令人惊叹的 Web 性能。我们的目标：使用 Astro 几乎不可能做出缓慢的网站。一个 Astro 网站可以比使用最受欢迎的 React Web 框架构建的同一网站加载速度快 40%，JavaScript 减少 90%。但不要直接相信我们的话：看 Astro 的性能让 Ryan Carniato（Solid.js 和 Marko 的创始人）说不出话来。易于使用Astro 的目标是使所有 Web 开发者都对它易于理解。Astro 被设计成熟悉和平易近人的感觉，无论技能水平或过去的 Web 开发经验如何。Astro 的 .astro UI 语言是 HTML 的超集：任何有效的 HTML 都是有效的 Astro 模板语法！因此，如果你能编写 HTML，你就可以编写 Astro 组件！但是，它还结合了我们从其他组件语言中借用的一些我们最喜欢的功能，如 JSX 表达式（React）和默认使用 CSS 作用域（Svelte 和 Vue）。这种与 HTML 的相似性也使得使用渐进式增强和常见的可访问性模式变得更加容易而无额外开销。我们然后确保你还可以使用你已经了解的最喜欢的 UI 组件语言，甚至可以复用你可能已经有的组件。React、Preact、Svelte、Vue、Solid、Lit 和其他的，包括 Web components，都被支持在 Astro 项目中编写 UI 组件。Astro 的设计比其他 UI 框架和语言更简单。其中一个重要原因是 Astro 被设计为在服务器上渲染，不是在浏览器中。这意味着你无需担心：hooks (React)、stale closures (还是 React)、refs (Vue)、observables (Svelte)、atoms、selectors、reactions、或 derivations。服务器上没有响应式，因此这些复杂性都消失了。我们最喜欢的说法之一是：复杂性是可选的。我们设计 Astro 是为了尽可能多地从开发者体验中消除“必须的复杂性”，尤其是你首次加入时。你可以在 Astro 中只使用 HTML 和 CSS 构建一个“Hello World”示例网站。然后，当你需要构建更强大的东西时，你随时可以逐渐取用新功能和 API。以开发者为中心我们坚信，只有当人们喜欢使用 Astro 时，Astro 才是一个成功的项目。Astro 有支持你使用 Astro 构建网站所需的一切。Astro 在开发者工具方面有所投入，例如从你打开终端的那一刻起就有的很棒的 CLI 体验、一个提供语法高亮的官方 VS Code 扩展、TypeScript 和 Intellisense，以及提供 14 种语言由数百名社区贡献者积极维护的文档。我们友善、尊重和包容的 Discord 社区已准备好提供支持、动力和鼓励。创建一个 #support 帖子来获取关于你的项目的帮助。访问我们专门的 #showcase 频道，分享你的 Astro 网站、博客文章、视频、甚至是半成品以获得安全的反馈和建设性的批评。参加定期的实时活动，如我们每周的社区会议、“Talking and Doc’ing”、以及 API/bug 修复。作为一个开源项目，我们欢迎各种经验程度的社区成员以各种类型和规模做出贡献。你被邀请参与路线图讨论以塑造 Astro 的未来，我们也希望你能为核心代码库、编译器、文档、语言工具、网站和其他项目贡献修复和功能。"},{"title":"从Hexo到Astro博客1分钟迁移指南","url":"/article/hexo-to-astro-1-minute-migration-guide","content":"从Hexo到Astro博客1分钟迁移指南 - 🎉 本文将介绍如何将 Hexo 博客迁移到 Astro 博客，只需要 1 分钟即可完成！作为 Hexo 的长期用户，我在 2024 年开始尝试 Astro，Hexo 基于模板引擎（EJS/Swig）的字符串拼接，而 Astro 采用基于 Vite 的组件化构建体系。Hexo 在 hexo generate 时完成全量渲染，Astro 在 astro build 时执行 SSG（静态站点生成）+ ISR（增量静态再生）。Astro 的组件化架构、按需加载，构建速度、Vite 驱动，热更新速度快等现代化开发体验 深深吸引了我！项目结构对比HexoAstro说明_config.ymlsrc/config.ts配置文件sourcesrc/content/blog主内容目录themessrc/components组件目录publicpublic静态资源目录迁移步骤详解1. 初始化 Astro 项目# 创建美妙的 Astro 项目npm create astro@latest --template uxiaohan/bytAstro-Theme astro-blog# 进入项目目录cd astro-blog# 安装依赖npm install# 本地预览npm run dev迁移文章内容将 Hexo 博客的 src/_posts/ 目录下的文章文件，复制到 Astro 的 src/content/blog/ 目录下即可，然后自定义 src/config.ts 配置文件去自定义博客。⚠️ Hexo 的部署、使用、自动化部署等方法 完全适用于 Astro 博客！🎉 此时，你已成功迁移 Hexo 博客至 Astro 博客！Vercel 自动部署Vercel 一键部署Cloudflare Pages 自动部署Cloudflare Pages 一键部署其他更多部署方式（简简单单闭眼部署），请参考 Astro 官方文档。迁移后性能对比指标HexoAstro提升构建时间12.3s5.1s58%↑Lighthouse 性能8910012%↑页面大小145KB23KB84%↓总结迁移到 Astro 后，我的技术博客实现了：✅ 构建速度提升 2.4 倍✅ 页面性能评分全满分✅ 开发体验现代化✅ 扩展能力显著增强"},{"title":"cms采集站点集合","url":"/article/cms采集站点集合","content":"cms采集站点集合 - X 站长交流群里的老哥一直叫我把之前的站长工具导航弄回来，我只好把采集站做个综合贴了。这篇帖子我会持续更新，只要发现了新的 X 资源采集站就会写在这里，同时也欢迎任何 X 资源采集站或者 X 站长投稿。排名不分先后，资源站评论仅代表站长个人观点，如有不对请指出，你们有什么想吐槽的也欢迎留言。百万资源站#无水印视频资源站，只在视频内插播了一条广告，全程无水印遮挡，播放器也不跳转，业界良心！强烈推荐采集！网址： https://bwzy.tv115 资源站#带小说和色图资源，以前出过自己的 CMS，后来不知道怎么不弄了，10 万部片源左右。网址：http://155zy.comGay 资源站#2024 年新出的资源站点，有猎奇系列，人兽系列，人妖系列。。。比较多重口味视频的资源站。网址： https://gayzy.tv极品资源站#开局就是广告，播完广告后视频无水印，视频速度不错，就是资源少了点，有自己的一键部署 CMS。网址： https://jipinzy.com桃花资源站#未成年色情片一大堆，想死的站长可以采集一下试试，我不是吓你们，附上维基百科资料：https://zh.wikipedia.org/wiki/%E5%85%92%E7%AB%A5%E8%89%B2%E6%83%85wiki 百科网址： https://thzy1.me奥斯卡资源站#资源多，更新快，广告多。网址：https://aosikazy.com大地资源站#老牌资源站，17W 左右的片源。网址： https://dadizy.com探探资源站#带图片和小说资源采集。网址： https://tantanzy8.com森林资源站#带图片和小说资源采集，视频分类比较多。网址： https://senlinzy.com奶香香资源站#带图片和小说资源采集，带播放统计计费系统（有播放就有钱收），注：该资源站首页弹窗关不掉，很恶心人。网址： https://naixxzy1.com辣椒资源站#19 年到现在的老牌资源站，有自己的一键部署 CMS。网址：http://lajiaozy.com滴滴资源站#开局广告，2 万部片源。网址： https://didizy.com色猫资源站#视频分类多，顶部和右下角文字广告。网址： https://semaozy5.com鲨鱼资源站#17 万片源的老牌资源站，他们家的韩国伦理和香港伦理两个分类别采集，全是货不对板的视频。网址： http://shayuzy5.com黄瓜资源站#7 万部片源做了 35 个分类，有些国产视频分类乱七八糟，站长注意避坑。网址： https://avre00.comJKUN 资源站#带 14 万部色情小说采集资源，开局广告，全程开元棋牌右下角文字广告。网址： https://jkunzy.com玉兔资源站#右下角贼大的开源棋牌图片水印，有一些角度刁钻的片源可能会被水印挡住逼，有自己的一键部署 CMS。网址： https://yutuzy.comCK 资源采集网#没有 X 视频，全是伦理片采集的资源站，有乱七八糟的剧情介绍，广告也比较多，亮点是有很多中字伦理片。网址： https://ckzy1.com六大 X 资源联盟#视频右下角带有联盟网址引导，这种资源站仅适合拿来做站群采集使用。联盟网址： https://www.xzylm.com美少女资源站：https://www.msn7.motorcycles/cn/home/web/淫水机资源站：https://www.ysj2.hair/cn/home/web/香奶儿资源站：https://www.xne6.rest/cn/home/web/白嫖资源站：https://www.bp3.lol/cn/home/web/小湿妹资源站：https://www.xsm7.bond/cn/home/web/黄 AV 资源站：https://www.hav7.shop/cn/home/web/优优资源网#网址： https://yycmszyw.com顶尖传媒#以前 9CCMS 对接的资源站，包含撸死你资源站，yellow 字幕网，国产富二代，玖玖资源站，色色资源站，久草在线，女优馆，利来资源站，博天堂资源站，环亚资源站网址： https://djcm.btbtt39.com番号资源网#网址： http://fhzy10.com老色逼资源站#网址：https://laosebizy.com草榴资源网#网址： https://caoliuzyw.com"},{"title":"本地php环境安装","url":"/article/本地php环境安装","content":"本地php环境安装 - 我们这里以apple m2 系统为例子。我们以https://github.com/shivammath…第三方tap源为例子，官方的brew速度太慢了。这里文章主要分为两部分安装php安装composer这里我们安装php会分两种没有php情况已有php情况，比如php7.3，我们要更新成php7.4。我们这里使用 https://github.com/hisheng/first 测试php代码其中composer.json里面php的版本要求7.3.0以上\"require\": {    \"php\": \">=7.3.0\",    \"phpunit/phpunit\": \"^4.8\"}一、安装php步骤之—（没有php环境的情况）1、查看 php 版本php -v此时发现没有php环境的话，就全新安装2、brew tap加速，使用github库homebrew默认使用官方的库，但这个源很慢，一般我们会使用第三方tap  brew tap shivammathur/php3、安装php7.3  brew install shivammathur/php/php@7.34、创建link，这样可以在全局环境里访问  brew link --overwrite --force php@7.35、查看是否安装 php -v我们会发现已经安装好了PHP 7.3.33 (cli) (built: Dec  8 2022 08:29:04) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.3.33, Copyright (c) 1998-2018 Zend Technologieswith Zend OPcache v7.3.33, Copyright (c) 1999-2018, by Zend Technologies二、安装php步骤之—（已经安装php环境的情况）在上面我们介绍了，mac电脑里，没有php环境的安装的方法，其实大部分情况下，我们的电脑已经有php了，此时要更新php版本如何做呢？1、查看 php 版本php -v此时我们发现了安装了php7.3PHP 7.3.33 (cli) (built: Dec  8 2022 08:29:04) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.3.33, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.3.33, Copyright (c) 1999-2018, by Zend Technologies2、brew tap加速，使用github库homebrew默认使用官方的库，但这个源很慢，一般我们会使用第三方tapbrew tap shivammathur/php3、安装php7.4brew install shivammathur/php/php@7.44、创建link，这样可以在全局环境里访问brew link --overwrite --force php@7.45、查看是否安装 php -v我们会发现已经安装好php7.4了,我们看下返回如下：PHP 7.4.33 (cli) (built: Dec  8 2022 21:24:25) ( NTS )Copyright (c) The PHP GroupZend Engine v3.4.0, Copyright (c) Zend Technologies    with Zend OPcache v7.4.33, Copyright (c), by Zend Technologies三、安装composercomposer已经是php开发必要的库了，每次安装完php后。第一件事，我们就是按照composer。1、下载composerhttps://getcomposer.org/downl…我们可以看到官方文档已经给出下载的方式我们可以执行下面的命令下载：image.png2、把composer放到 全局环境变量中mv composer.phar /usr/local/bin/composer四、项目初始化。1、下载php代码我们这里使用https://github.com/hisheng/first我以前的一个php项目为例子。git clone git@github.com:hisheng/first.git2、进入到项目中，执行composer install安装扩展初始化项目cd firstcomposer install执行完成后，我们会看到项目多了一个vendor包，这里就是我们用到依赖。"},{"title":"css文本超出一定范围后显示省略号","url":"/article/css文本超出一定范围后显示省略号","content":"css文本超出一定范围后显示省略号 - 在CSS中，如果你希望文本超出一定范围后显示省略号，可以使用以下的样式来实现：.ellipsis {    white-space: nowrap;        /* 不允许换行 */    overflow: hidden;           /* 隐藏超出的内容 */    text-overflow: ellipsis;   /* 用省略号表示超出的内容 */}你可以将这些样式应用到相关的HTML元素上。例如：    这是一个非常长的文本，如果它超过了容器的宽度，就会显示省略号。此外，如果你想要对多行文本应用相似的效果，可以使用 CSS 的 -webkit-line-clamp 属性（在 WebKit 及 Blink 渲染引擎下支持），如下所示：.multi-line-ellipsis {    display: -webkit-box;               /* 使用弹性盒布局 */    -webkit-box-orient: vertical;      /* 垂直方向排列 */    -webkit-line-clamp: 2;             /* 设定显示的行数 */    overflow: hidden;                   /* 隐藏超出部分 */}对应的 HTML 代码可以是：    这是一个非常长的文本，如果它超过了容器的宽度，并且行数超过了设定的数量，就会显示省略号。这里再添加一些内容，以便它能超出限制。记得为这段代码设置一个固定的高度，或者限制其宽度，以便能看到省略号的效果。"},{"title":"使用epub.js解析epub文件","url":"/article/使用epub.js解析epub文件","content":"使用epub.js解析epub文件 - 使用 epub.js 解析 EPUB 文件在 JavaScript 环境下可以非常方便，尤其是结合像 Astro.js 这样的现代框架。以下是一个简单的指导，帮助你在 Astro.js 项目中使用 epub.js 解析和展示 EPUB 文件。步骤 1: 创建一个新的 Astro.js 项目如果你还没有创建 Astro 项目，可以使用以下命令创建一个新的项目：npm create astro@latestcd your-project-namenpm install步骤 2: 安装 epub.js在项目目录中安装 epub.js：npm install epubjs步骤 3: 创建一个组件来显示 EPUB 文件你可以创建一个新的 Astro 组件，例如 EpubViewer.astro，用来加载和显示 EPUB 文件。---// EpubViewer.astroimport { onMount } from 'astro:client';import Epub from 'epubjs';const { src } = Astro.props;let book, rendition;onMount(async () => {    book = Epub(src);    // 读取EPUB文件    await book.loaded;    // 创建一个 Rendition，并指定要渲染 EPUB 的 HTML 元素    const bookContainer = document.getElementById('book');    rendition = book.renderTo(bookContainer, {        width: '100%',        height: '100%',    });    // 加载第一页    rendition.display();});---步骤 4: 在页面中使用 EpubViewer 组件在你的页面中引用 EpubViewer 组件并传入一个 EPUB 文件的路径：---// src/pages/index.astroimport EpubViewer from '../components/EpubViewer.astro';const epubFilePath = '/path/to/your/book.epub'; // 替换为你的EPUB文件的路径---    EPUB Viewer    EPUB Viewer    步骤 5: 准备 EPUB 文件确保在 public 文件夹中有你的 EPUB 文件，使用相对路径指定文件位置。步骤 6: 启动项目最后，启动你的 Astro 项目：npm run dev现在，你应该能够在浏览器中查看 EPUB 文件的内容。注意事项CSS 样式：你可能需要添加一些 CSS 样式来控制阅读器的外观和感觉。事件处理：可以根据需要添加事件处理函数，例如对翻页、缩放等功能的支持。错误处理：加强错误处理机制来处理文件加载错误或格式错误。这样，你就能在 Astro.js 项目中使用 epub.js 来解析和显示 EPUB 文件！"},{"title":"《毛概》读后感","url":"/article/《毛概》读后感","content":"《毛概》读后感 - 本文由ai自动生成，仅供参考。《毛概》这本书是对毛泽东思想的系统总结与梳理，是我们了解中国现代历史、特别是中国共产党和毛泽东领导下的革命历程的重要读物。读完这本书，我深刻体会到了毛泽东思想在中国历史发展中的重要性，同时也对其理论背景、历史意义以及现实启示有了更深的认识。首先，书中对于毛泽东思想的阐述，让我明白了其形成的历史背景和理论依据。毛泽东思想是在中国特定的历史条件下发展起来的，是对马克思列宁主义的中国化运动的结果。中国在20世纪初面临着内外困扰，社会动荡、民族危机深重，这一背景促使马克思主义在中国生根发芽，而毛泽东则在实践中不断探索适合中国国情的革命道路。这种对具体国情与历史背景的深刻理解，以及在实践中不断反思与修正的态度，是毛泽东思想最宝贵的部分。其次，书中讲述的毛泽东的理论成果，尤其是关于新民主主义革命、社会主义革命和建设的理论，让我对于中国共产党的领导方针有了更为系统的理解。毛泽东提出的新民主主义阶段，将中国革命划分为两个阶段，不仅适应了当时中国的国情，也为后来的社会主义建设奠定了基础。这种理论的灵活性与创新性，体现了毛泽东作为一个杰出政治家的智慧，他在针对中国社会不同阶段问题时提出的解决方案，至今仍值得我们认真研究和借鉴。再者，我被书中关于群众路线的部分深深打动。毛泽东强调“从群众中来，到群众中去”，这一原则不仅是他革命实践的基础，也是其理论的一部分。在当前的社会背景下，这一观点依然有着重要的现实意义。现代社会各类问题层出不穷，政府治理面临诸多挑战，而呼唤“从群众中来”的思路，无疑为今天的治理提供了理论支撑和实践指导。通过尊重群众，听取群众的声音，才能更好地服务于民、解决问题。此外，《毛概》还让我反思了历史的复杂性与多样性。毛泽东在革命中采取的某些极端措施虽在一定历史背景下取得了成功，但也带来了诸多反思和教训。在学习毛泽东思想的过程中，我们也要保持理性，对历史进行深入的剖析。只有在认识历史的基础上，才能更好地面对今天的挑战，推动社会的进步。最后，读完《毛概》，我感受到一种深厚的历史责任感。作为新时代的青年，我们既要继承历史的经验，也要面向未来。在建设社会主义事业的道路上，我们需要更多地关注当下社会的实际问题，把创新与发展的思路运用到实践中去。同时，也要保持批判性思考，不断进行理论上的深化与拓展。总之，《毛概》是一本值得深入阅读和思考的书籍，它不仅是对毛泽东思想的全面总结，也为我们今天的社会发展提供了深刻的历史启示。在未来的学习和工作中，我将牢记这些思想，努力为实现中华民族伟大复兴的中国梦贡献自己的力量。"},{"title":"NestJS入门指南","url":"/article/NestJS入门指南","content":"NestJS入门指南 - 本文由ai自动生成，仅供参考。NestJS入门指南一、什么是NestJSNestJS是一个用于构建高效、可扩展的Node.js服务器端应用程序的框架。它采用TypeScript编写，并结合了面向对象编程、函数式编程和响应式编程的元素。NestJS的设计理念是通过模块化的方式构建应用，使得各个部分之间的耦合度降低，从而提升代码的可维护性与可扩展性。二、NestJS的特点模块化：NestJS使用模块的方式将应用组织起来。每个模块可以包含控制器、服务以及其他组件，从而使得代码结构清晰。依赖注入：NestJS内置强大的依赖注入容器，使得组件之间的依赖管理变得简单，提高了代码的可测试性。高性能：NestJS基于Fastify和Express.js等高性能的Web框架，具备良好的性能表现。易于测试：NestJS鼓励使用单元测试和集成测试，提供了良好的测试支持。丰富的生态系统：NestJS有着活跃的社区和众多的插件，可以快速集成各种功能，如认证、数据库访问等。三、环境搭建安装Node.jsNestJS需要Node.js的支持，建议安装LTS版本。可以在Node.js官网下载并安装。安装Nest CLINest CLI是NestJS的命令行工具，可以帮助开发者快速生成Nest应用及各类组件。在终端中执行以下命令安装：npm install -g @nestjs/cli3. 创建NestJS项目使用Nest CLI创建新的NestJS项目，命令如下：nest new project-name根据提示选择包管理工具（npm或yarn）完成项目的初始化。四、基本项目结构使用Nest CLI创建的项目包含以下基本结构：project-name├── src│   ├── app.controller.ts│   ├── app.controller.spec.ts│   ├── app.module.ts│   ├── app.service.ts│   ├── main.ts├── test├── node_modules├── package.json├── tsconfig.json└── …主要文件介绍main.ts: 应用程序的入口文件，负责应用的引导。app.module.ts: 根模块，包含应用中所有其他模块。app.controller.ts: 控制器，负责处理请求，并返回响应。app.service.ts: 服务，包含业务逻辑，可以被其他组件注入。五、创建第一个RESTful API创建控制器使用Nest CLI创建一个新的控制器：nest generate controller users这将在src目录下生成一个users目录，包含users.controller.ts文件。我们将在这里定义用户相关的路由。import { Controller, Get } from '@nestjs/common';@Controller('users')export class UsersController {  @Get()  findAll(): string {    return 'This action returns all users';  }}创建服务接下来，创建一个与控制器配套的服务：nest generate service users在users.service.ts中，我们可以定义一些业务逻辑：import { Injectable } from '@nestjs/common';@Injectable()export class UsersService {  private readonly users = ['John', 'Jane', 'Jim'];  findAll(): string[] {    return this.users;  }}绑定服务到控制器现在我们将服务注入到控制器中，以获取用户数据：import { Controller, Get } from '@nestjs/common';import { UsersService } from './users.service';@Controller('users')export class UsersController {  constructor(private readonly usersService: UsersService) {}  @Get()  findAll(): string[] {    return this.usersService.findAll();  }}更新应用模块记得在app.module.ts中导入UsersModule，使得控制器和服务能够工作：import { Module } from '@nestjs/common';import { UsersController } from './users/users.controller';import { UsersService } from './users/users.service';@Module({  imports: [],  controllers: [UsersController],  providers: [UsersService],})export class AppModule {}启动应用在项目根目录下运行以下命令启动Nest应用：npm run start打开浏览器，访问http://localhost:3000/users，将会看到返回的用户列表。六、使用数据库NestJS可以与多种数据库轻松集成，我们选择使用TypeORM和SQLite作为示例。安装依赖在项目中安装TypeORM和SQLite驱动：npm install —save @nestjs/typeorm typeorm sqlite32. 配置TypeORM在项目的app.module.ts中配置TypeORM：import { Module } from '@nestjs/common';import { TypeOrmModule } from '@nestjs/typeorm';import { UsersController } from './users/users.controller';import { UsersService } from './users/users.service';import { User } from './users/user.entity';@Module({  imports: [    TypeOrmModule.forRoot({      type: 'sqlite',      database: 'db.sqlite',      entities: [User],      synchronize: true,    }),    TypeOrmModule.forFeature([User]),  ],  controllers: [UsersController],  providers: [UsersService],})export class AppModule {}创建实体创建一个用户实体类user.entity.ts：import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';@Entity()export class User {  @PrimaryGeneratedColumn()  id: number;  @Column()  name: string;}更新服务在users.service.ts中更新代码以使用数据库：import { Injectable } from '@nestjs/common';import { InjectRepository } from '@nestjs/typeorm';import { Repository } from 'typeorm';import { User } from './user.entity';@Injectable()export class UsersService {  constructor(    @InjectRepository(User)    private usersRepository: Repository,  ) {}  async findAll(): Promise {    return this.usersRepository.find();  }}更新控制器在users.controller.ts中更新控制器以返回用户数据：import { Controller, Get } from '@nestjs/common';import { UsersService } from './users.service';import { User } from './user.entity';@Controller('users')export class UsersController {  constructor(private readonly usersService: UsersService) {}  @Get()  async findAll(): Promise {    return this.usersService.findAll();  }}测试API重新启动应用，并访问http://localhost:3000/users，我们将看到从数据库中获取的用户信息。七、添加新的路由除了GET请求外，我们还可以添加其他HTTP请求，例如POST、PUT和DELETE。创建新的DTO创建新的DTO（数据传输对象）用于验证用户输入。在users目录下创建create-user.dto.ts：export class CreateUserDto {  name: string;}更新控制器以支持POST请求在users.controller.ts中添加POST请求处理逻辑：import { Controller, Get, Post, Body } from '@nestjs/common';import { UsersService } from './users.service';import { CreateUserDto } from './create-user.dto';import { User } from './user.entity';@Controller('users')export class UsersController {  constructor(private readonly usersService: UsersService) {}  @Get()  async findAll(): Promise {    return this.usersService.findAll();  }  @Post()  async create(@Body() createUserDto: CreateUserDto): Promise {    return this.usersService.create(createUserDto);  }}更新服务以支持创建用户在users.service.ts中添加创建用户的方法：async create(createUserDto: CreateUserDto): Promise {  const user = this.usersRepository.create(createUserDto);  return this.usersRepository.save(user);}八、总结在本指南中，我们介绍了NestJS的基本知识、环境搭建、创建基本的RESTful API、与数据库的集成以及如何处理不同的HTTP请求。NestJS是一个功能强大的框架，适合构建复杂的服务器端应用。要深入学习NestJS，建议查看其官方文档，其中包含更多的主题，如中间件、管道、守卫等。通过不断实践和学习，您将能够更好地掌握NestJS的使用。希望本指南对您的NestJS学习之旅有所帮助！"},{"title":"js实现俄罗斯方块","url":"/article/js实现俄罗斯方块","content":"js实现俄罗斯方块 - 本文由ai自动生成，仅供参考。实现一个简化版本的俄罗斯方块（Tetris）游戏需要使用HTML、CSS和JavaScript。以下是一个简单的例子，展示了如何使用这些技术来构建一个基础的俄罗斯方块游戏。HTML            俄罗斯方块        俄罗斯方块                开始游戏        CSS (style.css)body {    display: flex;    flex-direction: column;    align-items: center;    background-color: #f0f0f0;}canvas {    border: 1px solid #000;    background-color: #fff;}h1 {    font-family: 'Arial', sans-serif;}JavaScript (script.js)const canvas = document.getElementById('board');const ctx = canvas.getContext('2d');const ROWS = 20;const COLS = 10;const BLOCK_SIZE = 20;const COLORS = [    null,    'cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'];const SHAPES = [    [],    [[1, 1, 1, 1]], // I    [[2, 2, 2], [0, 0, 2]], // L    [[3, 3, 3], [3, 0, 0]], // J    [[4, 4], [4, 4]], // O    [[5, 5, 0], [0, 5, 5]], // S    [[6, 6, 6], [0, 6, 0]], // T    [[7, 7, 7], [0, 0, 7]]  // Z];let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));let currentPiece;let currentPosition;// 生成新的方块function newPiece() {    const index = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;    currentPiece = {        shape: SHAPES[index],        color: COLORS[index],        row: 0,        col: Math.floor(COLS / 2) - 1    };}// 检查碰撞function isCollision(offsetRow, offsetCol) {    for (let r = 0; r = ROWS || newCol = COLS || board[newRow][newCol]) {                    return true;                }            }        }    }    return false;}// 将方块放入棋盘function placePiece() {    for (let r = 0; r = 0; r--) {        if (board[r].every(cell => cell)) {            board.splice(r, 1);            board.unshift(Array(COLS).fill(0));        }    }}// 绘制棋盘function drawBoard() {    ctx.clearRect(0, 0, canvas.width, canvas.height);    board.forEach((row, r) => {        row.forEach((cell, c) => {            if (cell) {                ctx.fillStyle = cell;                ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);                ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);            }        });    });    // 绘制当前方块    currentPiece.shape.forEach((row, r) => {        row.forEach((cell, c) => {            if (cell) {                ctx.fillStyle = currentPiece.color;                ctx.fillRect((currentPiece.col + c) * BLOCK_SIZE, (currentPiece.row + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);                ctx.strokeRect((currentPiece.col + c) * BLOCK_SIZE, (currentPiece.row + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);            }        });    });}// 下落方块function dropPiece() {    if (!isCollision(1, 0)) {        currentPiece.row++;    } else {        placePiece();        clearRows();        newPiece();        if (isCollision(0, 0)) {            alert('游戏结束！');            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));        }    }}// 控制方块移动function control(event) {    if (event.key === 'ArrowLeft' && !isCollision(0, -1)) {        currentPiece.col--;    } else if (event.key === 'ArrowRight' && !isCollision(0, 1)) {        currentPiece.col++;    } else if (event.key === 'ArrowDown') {        dropPiece();    }}// 游戏循环function gameLoop() {    dropPiece();    drawBoard();    setTimeout(gameLoop, 1000);}// 开始游戏document.getElementById('startButton').addEventListener('click', () => {    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));    newPiece();    gameLoop();});document.addEventListener('keydown', control);使用说明将以上代码分别保存到index.html、style.css和script.js文件中。打开index.html文件在浏览器中查看和玩游戏。游戏玩法使用箭头键控制方块的移动。按“开始游戏”按钮开始游戏。这个示例是一个非常简单的俄罗斯方块游戏实现，您可以根据需要进行扩展，例如增加得分系统、不同形状的方块、旋转方块、提高游戏难度等。"},{"title":"js实现贪吃蛇游戏","url":"/article/js实现贪吃蛇游戏","content":"js实现贪吃蛇游戏 - 本文由ai自动生成，仅供参考。js实现贪吃蛇游戏实现一个简单的贪吃蛇游戏可以使用 HTML 和 JavaScript。以下是一个基本的示例，通过画布（Canvas）来绘制游戏界面。            贪吃蛇游戏            canvas {            background: #f0f0f0;            display: block;            margin: 0 auto;        }                    const canvas = document.getElementById(\"gameCanvas\");        const ctx = canvas.getContext(\"2d\");        const box = 20; // 每个方块的大小        let snake = [{ x: 9 * box, y: 9 * box }];        let direction = '';        let food = {            x: Math.floor(Math.random() * 20) * box,            y: Math.floor(Math.random() * 20) * box        };        document.addEventListener(\"keydown\", changeDirection);                function changeDirection(event) {            if (event.key === \"ArrowUp\" && direction !== 'DOWN') {                direction = 'UP';            } else if (event.key === \"ArrowDown\" && direction !== 'UP') {                direction = 'DOWN';            } else if (event.key === \"ArrowLeft\" && direction !== 'RIGHT') {                direction = 'LEFT';            } else if (event.key === \"ArrowRight\" && direction !== 'LEFT') {                direction = 'RIGHT';            }        }        function collision(head, array) {            for (let i = 0; i = canvas.width || snakeY >= canvas.height || collision(newHead, snake)) {                clearInterval(game);                alert(\"游戏结束!\");            }            snake.unshift(newHead);        }        let game = setInterval(draw, 100); // 每100毫秒更新一次    如何运行复制上述代码。将其粘贴到一个 .html 文件中，例如 snake.html。使用浏览器打开该文件。简要说明使用 canvas 画布来绘制游戏界面。按键事件监听来控制蛇的移动方向。每次绘制时更新时间，检查蛇是否吃到食物，更新蛇的身体。检查游戏结束的条件（碰到边界或自己）。这是一个简单的贪吃蛇实现，你可以根据需要添加更多功能，比如得分系统、困难模式、暂停功能等。"},{"title":"NuxtJS入门指南","url":"/article/NuxtJS入门指南","content":"NuxtJS入门指南 - 本文由ai自动生成，仅供参考。## Nuxt.js 3.0 入门指南介绍Nuxt.js 是一个基于 Vue.js 的高性能框架，它为开发人员简化了构建服务端渲染 (SSR) 应用的流程。Nuxt.js 3.0 是该框架的最新版本，在性能、开发体验和功能方面都有显著改进。本指南将帮助您快速入门 Nuxt.js 3.0，展示如何使用其核心功能构建一个简单的应用。安装与设置要开始使用 Nuxt.js 3.0，首先确保您的开发环境中安装了 Node.js（推荐版本 14 及以上）。接下来，可以通过命令行工具创建新的 Nuxt 项目。npx nuxi init my-nuxt-appcd my-nuxt-appnpm install执行以上命令后，您会看到一个新的文件夹 my-nuxt-app，其中包含 Nuxt.js 的基本项目结构。项目结构Nuxt.js 3.0 的项目结构与之前的版本略有不同。以下是主要的文件和文件夹说明：/pages: 存放页面组件，Nuxt 会根据此文件夹的结构自动生成路由。/layouts: 用于定义应用的布局，您可以为不同页面指定不同的布局。/components: 存放可复用的 Vue 组件。/plugins: 用于定义应用的插件，您可以在此注册 Vue 插件或其他库。/store: Vuex 状态管理，管理应用状态。/middleware: 用于定义中间件，应用路由守卫。/assets: 存放静态文件，如样式、图片等。nuxt.config.ts: 配置文件，用于定义 Nuxt 的配置选项。创建页面在 Nuxt.js 中，创建页面非常简单。您只需要在 /pages 文件夹中创建 .vue 文件即可。例如，我们创建一个 index.vue 文件：      欢迎来到我的 Nuxt.js 3 应用！    关于我们  h1 {  color: #3490dc;}接下来，我们创建一个 about.vue 文件：      关于我们    返回首页  h1 {  color: #e3342f;}路由当您创建页面组件时，Nuxt.js 会自动为其生成路由。例如，index.vue 对应根路径 /，而 about.vue 对应路径 /about。运行开发服务器：npm run dev打开浏览器，访问 http://localhost:3000/，您将看到主页，并可以通过点击链接跳转到 “关于我们” 页面。创建布局在 Nuxt.js 中，您可以使用布局来管理页面的整体结构。我们可以在 /layouts 文件夹中创建一个新的布局 default.vue：            我的 Nuxt.js 应用              首页        关于我们                                  © 2023 我的 Nuxt.js 应用      header {  background: #3490dc;  color: white;  padding: 1em;}footer {  text-align: center;  padding: 1em;}使用组件在 /components 文件夹中，您可以存放可复用的 Vue 组件。例如，您可以创建一个按钮组件 BaseButton.vue：        import { defineProps } from 'vue';const props = defineProps({  backgroundColor: {    type: String,    default: '#3490dc'  }});const handleClick = () => {  console.log('按钮被点击了');};.base-button {  color: white;  padding: 0.5em 1em;  border: none;  border-radius: 4px;  cursor: pointer;}现在，我们可以在 index.vue 页面中使用这个按钮组件：      欢迎来到我的 Nuxt.js 3 应用！    点击我    关于我们  import BaseButton from '@/components/BaseButton.vue';h1 {  color: #3490dc;}状态管理在 Nuxt 3 中，Vuex 状态管理依然适用，但官方推荐使用 pinia 作为新的状态管理解决方案。以下是如何在 Nuxt.js 3 项目中使用 pinia 的步骤：首先安装 pinia：npm install pinia在 nuxt.config.ts 中添加 pinia 插件：import { defineNuxtConfig } from 'nuxt';export default defineNuxtConfig({  buildModules: ['@pinia/nuxt'],});创建一个新的 store。在 /stores 文件夹中创建 useCounterStore.js：import { defineStore } from 'pinia';export const useCounterStore = defineStore('counter', {  state: () => ({    count: 0,  }),  actions: {    increment() {      this.count++;    },    decrement() {      this.count--;    },  },});在页面中使用 store：      计数器: {{ counter.count }}    增加    减少  import { useCounterStore } from '@/stores/useCounterStore';const counter = useCounterStore();h1 {  color: #3490dc;}API 请求在 Nuxt.js 3.0 中，您可以利用 asyncData 和 fetch 方法进行 API 请求。以下示例展示了如何在页面加载时获取数据：      用户列表          {{ user.name }}      import { ref } from 'vue';const users = ref([]);const fetchUsers = async () => {  const response = await fetch('https://jsonplaceholder.typicode.com/users');  users.value = await response.json();};// 在组件加载时请求数据fetchUsers();h1 {  color: #3490dc;}中间件中间件是处理路由守卫的有效方式。您可以在 /middleware 文件夹中创建一个新的中间件 auth.js，用于检查用户是否已认证：export default defineNuxtRouteMiddleware((to, from) => {  const isAuthenticated = /* 检查用户是否已登录的逻辑 */;  if (!isAuthenticated) {    return navigateTo('/login');  }});然后，您可以在页面中添加中间件：export default definePageMeta({  middleware: 'auth',});插件Nuxt.js 允许您在应用中注册 Vue 插件。在 /plugins 文件夹中创建自定义插件。例如，创建一个插件 my-plugin.js：export default defineNuxtPlugin((nuxtApp) => {  // 在这里注册 Vue 插件  nuxtApp.vueApp.config.globalProperties.$myPluginFunction = () => {    console.log('Hello from my plugin!');  };});您可以在组件中使用此插件：  调用插件函数const callMyPluginFunction = () => {  $myPluginFunction();};部署部署 Nuxt.js 应用可以选择多种方式，例如 Vercel、Netlify 或传统的 VPS。以 Vercel 为例，您只需遵循以下步骤：在 Vercel 上创建一个新项目。将您的应用代码推送到 GitHub 或 GitLab。在 Vercel 上选择您推送的仓库进行自动部署。Vercel 会自动检测到 Nuxt.js 应用并为其配置适当的构建设置。总结通过本指南，您已经了解了 Nuxt.js 3.0 的基本用法，包括：项目设置与目录结构页面、布局与组件的创建状态管理与 API 请求路由守卫与中间件的使用插件的注册与使用应用的部署Nuxt.js 3.0 具有更快的性能和更好的开发体验，是构建现代 Web 应用的理想选择。随着您深入学习和实践，相信您能够使用 Nuxt.js 构建出高质量的应用。希望这篇指南能帮助您顺利入门！"},{"title":"NextJS入门指南","url":"/article/NextJS入门指南","content":"NextJS入门指南 - 本文由ai自动生成，仅供参考。Next.js 入门指南目录什么是 Next.jsNext.js 的核心特性环境准备创建第一个 Next.js 应用页面路由静态生成与服务器端渲染数据获取API 路由样式处理部署 Next.js 应用总结1. 什么是 Next.jsNext.js 是一个基于 React 的开源框架，由 Vercel 创建。它提供了一系列特性，使得构建现代 web 应用变得更加简单和高效。Next.js 的核心理念是“开发者体验”和“生产就绪”。借助于 Next.js，开发者可以轻松地创建具有高性能、高可扩展性的应用。主要特点：静态生成（Static Generation）：可以在构建时生成 HTML，即安全且快速的页面。服务器端渲染（Server-Side Rendering）：在请求时生成 HTML，适用于数据实时变化的页面。API 路由：可以在 Next.js 应用中轻松创建无服务器的 API。文件系统路由：基于文件的路由，非常直观。CSS 和 Sass 支持：内置支持 CSS Modules 和 Sass。2. Next.js 的核心特性Next.js 提供了多种特性，使得开发过程更为高效，以下是一些核心特性：文件系统路由：通过在 pages 目录中添加文件来创建路由。内置的 CSS 和 Sass 支持：支持多种样式解决方案，可以无缝地使用 CSS Modules 和全局 CSS。支持 TypeScript：Next.js 默认支持 TypeScript。支持静态导出：可以将 Next.js 应用导出为静态网站。图像优化：内置的图像优化功能可以自动处理图像的尺寸和格式。3. 环境准备在开始使用 Next.js 之前，需要确保你的系统中已安装以下工具：Node.js：Next.js 需要 Node.js 环境，可以通过 Node.js 官网 下载和安装。npm 或 yarn：Node.js 安装完成后，npm（Node 包管理器）会自动安装。你也可以选择安装 yarn。安装 Node.js 的步骤：下载并安装 Node.js。验证安装：在命令行中输入以下命令，查看 Node.js 和 npm 的版本。node -vnpm -v4. 创建第一个 Next.js 应用在安装好 Node.js 和 npm 后，接下来就可以创建一个新的 Next.js 应用。使用 Create Next AppNext.js 提供了一个官方的脚手架工具 Create Next App，方便用户快速创建项目。可以通过以下命令利用 Create Next App 创建一个新的 Next.js 项目：npx create-next-app@latest my-next-app上面的命令会创建一个名为 my-next-app 的新文件夹，并在其中生成一个新的 Next.js 应用。进入项目目录并启动开发服务器cd my-next-appnpm run dev运行后，打开浏览器并访问 http://localhost:3000，你应该能看到默认的 Next.js 欢迎页面。5. 页面路由在 Next.js 中，路由是基于文件系统的。任何在 pages 目录中创建的 JavaScript 文件都会自动成为一个路由。创建页面打开 pages/index.js 文件，你会看到默认的内容。通常，这个文件对应的是首页。创建一个新的文件 about.js，并添加以下内容：export default function About() {  return About Page;}保存文件后，访问 http://localhost:3000/about，应能看到“About Page”。嵌套路由你还可以通过在 pages 目录中创建子目录来创建嵌套路由。例如，创建 pages/blog/index.js 和 pages/blog/[id].js：pages/blog/index.js：export default function Blog() {  return Blog Home;}pages/blog/[id].js：export default function Post({ params }) {  return Blog Post: {params.id};}这样，当访问 http://localhost:3000/blog 会显示“Blog Home”，而访问 http://localhost:3000/blog/1 会显示“Blog Post: 1”。6. 静态生成与服务器端渲染Next.js 支持两种页面渲染方式：静态生成和服务器端渲染。静态生成使用 getStaticProps 函数可以在构建时生成页面。例如，创建一个新的页面 pages/static.js：export async function getStaticProps() {  // 在此处获取数据  const data = { message: 'This is static generated content' };  return {    props: {      data,    },  };}export default function StaticPage({ data }) {  return {data.message};}当你访问 /static 时，这个页面的内容将在构建时生成。服务器端渲染使用 getServerSideProps 函数可以在每次请求时生成页面内容：export async function getServerSideProps() {  // 在此处获取数据，例如从数据库  const data = { message: 'This is server-side rendered content' };  return {    props: {      data,    },  };}export default function ServerRenderedPage({ data }) {  return {data.message};}访问 /server 时，页面内容会在每次请求时生成。7. 数据获取Next.js 提供了几种数据获取方法：getStaticProps：用于静态生成，即构建时获取数据。getServerSideProps：用于服务器端渲染，即每次请求时获取数据。getStaticPaths：与 getStaticProps 结合使用，用于动态路由的静态生成。使用 getStaticPaths 进行动态路由的静态生成在 pages/posts/[id].js 中，你可以这样设置：export async function getStaticPaths() {  const paths = [{ params: { id: '1' } }, { params: { id: '2' } }];  return { paths, fallback: false };}export async function getStaticProps({ params }) {  const data = { id: params.id, content: `This is post ${params.id}` };  return { props: { data } };}export default function Post({ data }) {  return {data.content};}8. API 路由Next.js 允许你创建后端 API，只需在 pages/api 目录中添加文件即可。创建简单的 API创建一个新的文件 pages/api/hello.js：export default function handler(req, res) {  res.status(200).json({ message: 'Hello from API!' });}在浏览器中访问 http://localhost:3000/api/hello，你会看到 {\"message\":\"Hello from API!\"} 的响应。9. 样式处理Next.js 内置支持 CSS 和 Sass，可以使用 CSS Modules 来生成独特的 CSS 类。使用 CSS Modules创建一个 CSS 文件，例如 styles/Home.module.css：.title {  color: blue;}在 pages/index.js 中引入并使用：import styles from '../styles/Home.module.css';export default function Home() {  return Hello Next.js!;}使用 Sass安装 Sass：npm install sass创建一个 Sass 文件，例如 styles/Home.module.scss，并使用：.title {  color: red;}在 pages/index.js 中引入并使用：import styles from '../styles/Home.module.scss';10. 部署 Next.js 应用Next.js 应用可以轻松部署到多个平台，如 Vercel、Netlify 或自托管服务器。部署到 Vercel注册一个 Vercel 帐户。通过 vercel CLI 部署你的应用：npm i -g vercelvercel部署到其他平台对于其他平台，通常只需构建应用并将输出内容部署到服务器。构建应用：npm run build输出内容通常在 .next 目录下，你可以将其上传到静态托管服务。11. 总结Next.js 是一个强大且灵活的框架，结合了静态生成和服务器端渲染的优点，使得开发人员能够轻松构建高性能的 web 应用。通过内置的路由、API 路由、数据获取函数及样式处理，Next.js 帮助开发者简化了许多繁琐的流程。希望这份入门指南能帮助你快速上手 Next.js，开启你的前端开发之旅！如果你有任何问题或需要更深入的学习，欢迎查阅 Next.js 官方文档。"},{"title":"deepseek将ai带入新的阶段","url":"/article/deepseek将ai带入新的阶段","content":"deepseek将ai带入新的阶段 - deepseek将ai带入新的阶段Deepseek 是一项引人注目的技术创新，它将人工智能（AI）推向了一个新的阶段，尤其是在信息检索和知识发现领域。作为一个先进的深度学习模型，Deepseek 的核心理念是通过深度学习技术，实现更高效、更精准的信息检索。这种技术的出现，不仅改变了我们获取信息的方式，也为各种行业带来了深远的影响。首先，Deepseek 的技术基础源于深度学习和自然语言处理（NLP）。通过对海量数据的学习，Deepseek 能够理解和处理人类语言的复杂性，从而提供更符合用户需求的搜索结果。与传统的关键词匹配搜索引擎不同，Deepseek 采用了更为智能化的语义理解机制，使得它能够识别用户意图、上下文及相关性，从而提供更精准的答案。这种进步使得用户在进行信息检索时不再局限于简单的关键词，而是可以通过自然语言进行问询，极大地提升了用户体验。其次，Deepseek 在处理大数据方面展现了卓越的能力。在当前信息爆炸的时代，如何快速找到所需信息已成为一个巨大的挑战。Deepseek 利用其强大的算法和计算能力，可以在瞬间对海量数据进行分析和处理。这种高效性不仅适用于学术研究和信息查询，也为商业领域带来了崭新的机遇。例如，企业可以通过 Deepseek 对市场趋势、消费者行为等进行深度分析，从而制定更为精准的营销策略。另外，Deepseek 的应用领域涵盖了多个行业，如医疗、金融、教育和法律等。在医疗领域，医生可以借助 Deepseek 快速获取相关的病理信息和研究资料，从而提高诊断的准确性。在金融行业，分析师可以利用 Deepseek 对市场数据进行深入剖析，预测市场走势，降低投资风险。在教育领域，学生和教师能够通过 Deepseek 获取更多有价值的学习资源，实现个性化学习。然而，Deepseek 的发展也带来了一些挑战与思考。首先，如何确保信息的准确性和可靠性是一个亟待解决的问题。由于网络上存在大量的虚假信息和噪声数据，Deepseek 需要有效的机制来筛选和验证信息源，以保障搜索结果的可信度。此外，随着 AI 技术的进步，隐私保护和数据安全问题也备受关注。在使用 Deepseek 进行信息检索的过程中，如何保护用户的个人信息，避免滥用和泄露，成为了一个重要的课题。总的来说，Deepseek 的出现标志着人工智能技术在信息检索领域的重要突破。它不仅提升了信息获取的效率和准确性，还为各行各业的决策提供了更为可靠的数据支持。然而，随着技术的快速发展，我们也必须不断思考如何平衡技术的应用与伦理规范，以更好地利用这项技术造福社会。"},{"title":"astro集成aplayer播放器","url":"/article/astro集成aplayer播放器","content":"astro集成aplayer播放器 - 本文详细阐述了在Astro框架中集成aplayer音乐播放器的完整流程。通过npm安装插件后创建动态播放器组件，引入APlayer并处理自动播放逻辑。针对Astro默认路由刷新问题，通过配置ClientRouter组件和transition。最后特别给出替换meeting-js为meting API的解决方案，包含自动获取播放列表数据、浏览器自动播放策略兼容处理等关键技术细节。astro集成aplayer播放器本文交大家如何在Astro项目中集成aplayer播放器。步骤1：安装aplayer插件pnpm i aplayer --save步骤2：创建Aplayer组件components 目录下创建 Aplayer.astro 文件：---import 'aplayer/dist/APlayer.min.css'; // 引入 APlayer 的样式文件---    import APlayer from 'aplayer';    let player;    let playerContainer;    // 在组件加载时初始化播放器并恢复状态    document.addEventListener('DOMContentLoaded', async () => {      playerContainer = document.getElementById('player-container');      player = new APlayer({        container: playerContainer,        autoplay: true,        fixed: true,        audio: [{            name: '示例音频',            artist: '艺术家',            url: 'your-audio-file.mp3',            cover: 'your-cover-image.jpg',        }],      });    }, false);      // 在组件卸载时保存播放器状态    {/* document.addEventListener('unloaded', () => {      savedPlayerState = {        currentTime: player.currentTime,        paused: player.paused,        volume: player.volume,      };    }); */}  步骤3：Layout引入aplayer组件// ...import Aplayer from \"@/components/Aplayer.astro\";// ...步骤4：astro 项目开启 PWA （不刷新页面跳转， 类似Vue 单页面应用）关键步骤：由于astro 默认跳转页面会刷新浏览器，这样会导致播放状态被重置，我们需要手动开启PWA维持状态。Astro 提供了一个  视图过渡动画  路由组件, 视图过渡动画可以在不刷新浏览器的情况下更新页面内容，并在页面之间提供无缝的动画效果。全局引入 ClientRouterimport { ClientRouter } from 'astro:transitions';...{/* Icons */}...使用 transition 指令在页面导航时保持组件和 HTML 元素的状态（而不是替换它们）。注意事项如果你用meeting-js 播放器，transition:persist 可能失效（测试过无法保持状态）。建议使用 meeting api 接口获取数据，然后传递给 aplayer 播放器。参考如下：---import 'aplayer/dist/APlayer.min.css'; // 引入 APlayer 的样式文件---        /**   * {      \"title\": \"给自己的信\",      \"author\": \"苏见信 (信)\",      \"url\": \"https://api.i-meto.com/meting/api?server=netease&type=url&id=22854031&auth=3f09ae2cfed515c1ff494bb67558c22f724f1bcc\",      \"pic\": \"https://api.i-meto.com/meting/api?server=netease&type=pic&id=109951164092166041&auth=3f008fc744fe34cee424d02ace9c1aa03a52c990\",      \"lrc\": \"https://api.i-meto.com/meting/api?server=netease&type=lrc&id=22854031&auth=8faf0360b5c4e8d24891bef58886f8b0e4a5ae50\"  }   */    import APlayer from 'aplayer';    let player;    let playerContainer;    // 在组件加载时初始化播放器并恢复状态    window.addEventListener('load', async () => {      playerContainer = document.getElementById('player-container');      let params = {        server: 'netease',        type: 'playlist',        id: '60192',        r: Math.random()      }      let url = 'https://api.i-meto.com/meting/api'      //拼接参数        let paramsArray = [];      Object.keys(params).forEach(key => paramsArray.push(key + '=' + params[key]))        if (url.search(/\\?/) === -1) {          url += '?' + paramsArray.join('&')        } else {          url += '&' + paramsArray.join('&')      }      // ?server=netease&type=playlist&id=60192&r=0.49295886527008737      let res = await fetch(url, {})      let data = await res.json()      player = new APlayer({        container: playerContainer,        autoplay: true,        fixed: true,        lrcType: 3,        audio: [...data.map(el => ({          lrc: el.lrc,          name: el.title,          artist: el.author,          url: el.url,          cover: el.pic,        }))],      });      // 处理google浏览器内核自动播放问题      player.on('loadeddata', () => {        player.audio.muted = true        player.play()        player.audio.muted = false      })    }, false);"},{"title":"Typecho Blogging Platform","url":"/article/Typecho Blogging Platform","content":"Typecho Blogging Platform - Typecho Blogging PlatformTypecho is a PHP-based blog software and is designed to be the most powerful blog engine in the world.Typecho is released under the GNU General Public License 2.0.Main FeaturesMultiple databases support (MySQL, SQLite, PostgreSQL)Markdown SupportPlugin SupportTheme SupportCustom FieldsCustom PagesRequirementsPHP 7.4.0 or higherDatabase (MySQL, SQLite, PostgreSQL)MySQL 5.5.3 or higherSQLite 3.7.11 or higherPostgreSQL 9.1 or higherScreenshotsContributingPlease see CONTRIBUTING for details.启动服务php -S localhost:8000 ./index.php"},{"title":"hexo-theme-butterfly","url":"/article/hexo-theme-butterfly","content":"hexo-theme-butterfly - hexo-theme-butterfly📢 預覽: Butterfly / CrazyWong📖 文檔: 中文 / English💻 安裝Git 安裝本倉庫同時上傳到 Gitee，如果你訪問 Github 緩慢，可從 Gitee 中下載。在博客根目錄裡安裝穩定版【推薦】git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly如果想要安裝比較新的dev分支，可以git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterflynpm 安裝此方法只支持Hexo 5.0.0以上版本在博客根目錄裡npm i hexo-theme-butterfly⚙ 應用主題修改hexo配置文件_config.yml，把主題改為Butterflytheme: butterfly如果你沒有pug以及stylus的渲染器，請下載安裝： npm install hexo-renderer-pug hexo-renderer-stylus —save🎉 特色 卡片化設計 圓角化設計/直角化設計 支持二級目錄 雙欄設計 響應式主題 夜間模式 Pjax 文章閲讀模式 簡體和繁體轉換 電腦和手機都可查看TOC目錄 內置多種代碼配色（darker/pale night/light/ocean），可自定義代碼配色 代碼塊顯示代碼語言/關閉或展開代碼塊/代碼複製/代碼自動換行 可關閉文字複製/可開啟內容複製增加版權信息） 兩種搜索（ Algolia 搜索和本地搜索） Mathjax 和 Katex 內置404頁面 顯示字數統計 顯示相關文章 過期文章提醒 多種分享系統（Sharejs/Addtoany） 多種評論系統（Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/artalk） 支持雙評論部署 多種在線聊天（Chatra/Tidio/Crisp） 多種分析系統 谷歌廣告/手動廣告位置 各種站長驗證 修改網站配色 打字特效 activate_power_mode 多種背景特效（靜止彩帶/動態彩帶/Canvas Nest） 多種鼠標點擊特效（煙花/文字/愛心） 內置一種 Preloader 加載動畫和 pace.js 加載動畫條 不蒜子訪問統計 兩種大圖模式（Medium Zoom/Fancybox） Mermaid 圖表顯示 Chart.js 圖表顯示 照片牆 圖片懶加載 Instantpage/Snackbar彈窗/PWA…✨ 貢獻者  📷 截圖"},{"title":"Node.js 简介","url":"/article/Node.js 简介","content":"Node.js 简介 - Node.js 是一个开源和跨平台的 JavaScript 运行时环境。它是几乎所有类型项目的流行工具！Node.js 在浏览器之外运行 V8 JavaScript 引擎，即 Google Chrome 的核心。这使 Node.js 的性能非常出色。Node.js 应用在单个进程中运行，不会为每个请求创建新线程。Node.js 在其标准库中提供了一组异步 I/O 原语，可防止 JavaScript 代码阻塞，并且通常，Node.js 中的库是使用非阻塞范例编写的，这使得阻塞行为成为例外而不是常态。当 Node.js 执行 I/O 操作（如从网络读取、访问数据库或文件系统）时，Node.js 不会阻塞线程并浪费 CPU 周期等待，而是会在响应返回时恢复操作。这使 Node.js 能够使用单个服务器处理数千个并发连接，而​​不会带来管理线程并发的负担，这可能是错误的重要来源。Node.js 具有独特的优势，因为数百万为浏览器编写 JavaScript 的前端开发者现在能够编写服务器端代码以及客户端代码，而无需学习完全不同的语言。在 Node.js 中，可以毫无问题地使用新的 ECMAScript 标准，因为你不必等待所有用户更新其浏览器 - 你可以通过更改 Node.js 版本来决定使用哪个 ECMAScript 版本，并且还可以通过使用标志运行 Node.js 来启用特定的实验性功能。Node.js 应用示例Node.js 最常见的示例 Hello World 是一个 Web 服务器：const { createServer } = require('node:http');// import { createServer } from 'node:http'; // ES6+ 模块语法const hostname = '127.0.0.1';const port = 3000;const server = createServer((req, res) => {  res.statusCode = 200;  res.setHeader('Content-Type', 'text/plain');  res.end('Hello World');});server.listen(port, hostname, () => {  console.log(`Server running at http://${hostname}:${port}/`);});要运行此代码段，请将其保存为 server.js 文件并在终端中运行 node server.js。如果你使用 mjs 版本的代码，你应该将其保存为 server.mjs 文件并在终端中运行 node server.mjs。此代码首先包含 Node.js http 模块。Node.js 有一个很棒的 标准库，包括对网络的一流支持。http 的 createServer() 方法创建一个新的 HTTP 服务器并返回它。服务器设置为监听指定的端口和主机名。当服务器准备就绪时，将调用回调函数，在这种情况下通知我们服务器正在运行。每当收到新请求时，就会调用 request 事件，提供两个对象：请求（http.IncomingMessage 对象）和响应（http.ServerResponse 对象）。这两个对象对于处理 HTTP 调用至关重要。第一个提供请求详细信息。在此简单示例中，未使用此功能，但你可以访问请求标头和请求数据。第二个用于将数据返回给调用者。在这种情况下：res.statusCode = 200;我们将 statusCode 属性设置为 200，以指示成功响应。我们设置了 Content-Type 标头：res.setHeader('Content-Type', 'text/plain');我们关闭响应，将内容作为参数添加到 end()：res.end('Hello World\\n');如果你还没有这样做，download Node.js。"},{"title":"如何在Mac上新建SSH key","url":"/article/如何在Mac上新建SSH key","content":"如何在Mac上新建SSH key - SSH（Secure Shell）是一种加密的网络传输协议，允许用户安全地登录到远程服务器并执行命令。而SSH key则是一对用于身份验证的密钥，包括公钥和私钥。在Mac电脑上新建SSH key是保障远程连接安全的重要步骤。本文将详细介绍如何在Mac上生成SSH密钥对，并将其用于远程连接。一、打开终端首先，我们需要打开Mac电脑上的终端应用程序。终端是Mac上用于执行命令行指令的工具，它提供了与操作系统底层交互的接口。二、生成SSH密钥对在终端中，输入以下命令并按Enter键：ssh-keygen -t rsa -C \"你的邮箱地址\"这个命令告诉系统我们要生成一个RSA类型的SSH密钥对。RSA是一种广泛使用的公钥加密算法，用于数据加密和数字签名。三、设置文件名和存储位置执行上述命令后，系统会提示您输入文件名和存储位置。默认情况下，公钥和私钥文件将保存在用户主目录下的.ssh/文件夹中，并且文件名分别为id_rsa（私钥）和id_rsa.pub（公钥）。如果您不需要更改默认设置，可以直接按Enter键接受。四、设置密码（可选）接下来，系统会询问您是否要为私钥设置一个密码。这是一个可选步骤，但出于安全考虑，建议设置一个密码。如果设置了密码，每次使用私钥进行身份验证时，都需要输入这个密码。这样可以增加私钥的安全性，防止未经授权的人员使用。如果您选择设置密码，请按照提示输入并确认密码。如果您选择跳过此步骤，直接按Enter键即可。五、查看和使用密钥完成上述步骤后，SSH密钥对就已经生成并保存在了指定位置。您可以使用以下命令查看公钥的内容：cat ~/.ssh/id_rsa.pub执行该命令后，终端将显示公钥的内容。您可以将其复制并分享给需要您SSH访问的服务器或服务。私钥文件id_rsa应该妥善保管，不要将其泄露给未经授权的人员。私钥用于身份验证，只有持有正确私钥的用户才能通过SSH访问远程服务器。六、添加公钥到远程服务器或平台如果您需要将生成的公钥添加到某个远程服务器或平台（如GitHub），请按照以下步骤操作：登录到您需要添加SSH密钥的远程服务器或平台。找到SSH密钥的设置部分。不同的平台可能有不同的界面和操作流程，但通常可以在账户设置或安全设置中找到相关选项。创建一个新的SSH密钥，并将之前复制的公钥内容粘贴到对应的输入框中。保存设置，完成SSH密钥的添加。现在，您已经成功在Mac电脑上新建了SSH key，并将其添加到了需要的平台或远程服务器。通过SSH密钥进行身份验证，您可以更安全地进行远程连接和操作。请务必妥善保管您的私钥文件，避免泄露给未经授权的人员。七、替换github源# vim ~/.ssh/config 如果没有会自动新建这个文件Host github.com  Hostname ssh.github.com  Port 443如果拉取代码提示下面的，说明成功了boycott@boycotMac-mini byt.blog-pc % git pullThe authenticity of host 'github.com (127.0.0.1)' can't be established.ED25519 key fingerprint is xxx.This key is not known by any other names.Are you sure you want to continue connecting'(yes/no/[fingerprint])? yes# 输入yes，回车即可 Warning: Permanently added 'github.com' (ED25519) to the list of known hosts.Already up to date."},{"title":"自定义element-plus全局主题","url":"/article/自定义element-plus全局主题","content":"自定义element-plus全局主题 - 设置方法通过设置主要颜色变量实现换肤export const setHtmlStyleProp = () => {    /** 变量前缀 */    const PRE = '--el-color-primary'    /** 浅色变量前缀 */    const PRE_LIGHT = `${PRE}-light`    /** 深色变量前缀 */    const PRE_DARK = `${PRE}-dark`    /** 色阶 */    const Levels = [3, 5, 7, 8, 9]    /** 白色 */    const WHITE = '#FFFFFF'    /** 黑色 */    const BLACK = '#000000'    const config = useConfig()    let color:string = config.getColorVal(\"primaryColor\")    const html = document.documentElement    /**     * 混合颜色     */    const mix = (color1: string, color2: string, weight: number) => {        weight = Math.max(Math.min(Number(weight), 1), 0)        const r1 = parseInt(color1.substring(1, 3), 16)        const g1 = parseInt(color1.substring(3, 5), 16)        const b1 = parseInt(color1.substring(5, 7), 16)        const r2 = parseInt(color2.substring(1, 3), 16)        const g2 = parseInt(color2.substring(3, 5), 16)        const b2 = parseInt(color2.substring(5, 7), 16)        const r = Math.round(r1 * (1 - weight) + r2 * weight)        const g = Math.round(g1 * (1 - weight) + g2 * weight)        const b = Math.round(b1 * (1 - weight) + b2 * weight)        const _r = ('0' + (r || 0).toString(16)).slice(-2)        const _g = ('0' + (g || 0).toString(16)).slice(-2)        const _b = ('0' + (b || 0).toString(16)).slice(-2)        return '#' + _r + _g + _b    }    // 设置主要颜色变量 --el-color-primary    html.style.setProperty(PRE, color)    // 循环设置色阶颜色    // --el-color-primary-light-${level}    Levels.forEach(level => {        html.style.setProperty(`${PRE_LIGHT}-${level}`, mix(color, WHITE, level * 0.1))    })    // 设置主要暗色    // --el-color-primary-dark-2    const dark = mix(color, BLACK, 0.2)    html.style.setProperty(`${PRE_DARK}-2`, dark)}"},{"title":"md-editor-v3,支持滚动，预览的markdown插件！","url":"/article/md-editor-v3,支持滚动，预览的markdown插件！","content":"md-editor-v3,支持滚动，预览的markdown插件！ - md-editor-v3    vue3 环境的 Markdown 编辑器，使用 jsx 和 typescript 语法开发。文档与在线预览：传送门同系列react版本：md-editor-rt功能一览快捷插入内容工具栏、编辑器浏览器全屏、页面内全屏等；内置的白色主题和暗黑主题，支持绑定切换；支持快捷键插入内容； 支持使用 prettier 格式化内容（使用 CDN 方式引入，只支持格式化 md 内容，可在代码内设置关闭）；多语言，支持自行扩展语言；粘贴上传图片，图片裁剪上传；仅预览模式（不显示编辑器，只显示 md 预览内容，无额外监听）；预览主题，内置default、vuepress、github 、cyanosis、mk-cute、smart-blue 6 种预览主题（不完全相同），支持自定义主题（参考文档 demo 页示例）；mermaid绘图（>=1.8.0），katex数学公式（>=1.9.0）；自定义工具栏顺序或显示，自定义扩展工具栏（支持点击类型、下拉菜单类型及弹窗类型）等。按需引用(>=4.0.0)。预览图默认模式暗黑模式仅预览输入提示和自定义简单的标记、表情扩展预览安装yarn add md-editor-v3使用已存在的语言、主题扩展，例如：日语yarn add @vavt/cm-extension使用更多的扩展工具栏组件，例如：导出内容为 PDFyarn add @vavt/v3-extension更多使用及贡献方式参考：md-editor-extension用法从v4.0.0开始，内部组件支持按需引用。编辑器模式  import { ref } from 'vue';import { MdEditor } from 'md-editor-v3';import 'md-editor-v3/lib/style.css';const text = ref('# Hello Editor');仅预览模式    import { ref } from 'vue';import { MdPreview, MdCatalog } from 'md-editor-v3';import 'md-editor-v3/lib/preview.css';const id = 'preview-only';const text = ref('# Hello Editor');const scrollElement = document.documentElement;当使用服务端渲染时，scrollElement应该是字符类型，例：html、body、#id、.class。更多用法请前往 文档。"},{"title":"【开源】Tarot-塔罗牌占卜","url":"/article/kaiyuan-tarot","content":"【开源】Tarot-塔罗牌占卜 - 塔罗牌占卜作为一种深受人们喜爱的心理探索工具，已经成为许多人自我反思与探索人生的方式之一。Tarot-Web是一款基于Web的塔罗牌占卜应用，它提供了22种不同的塔罗牌，每一张卡片都融合了传统塔罗的象征意义与AI的独特解读能力。页面截图点击体验项目地址Tarot-Web - Github如何部署1、准备一个 Cloudflare 账户2、Fork 本仓库，自由修改App.vue和index.html文件中的文案3、登录Cloudflare Dashboard打开Workers 和 Pages创建Pages4、连接到Git选择Github或Gitlab中你刚刚Fork的项目，点击开始设置5、只需要修改框架预设为Vue即可，点击保存并部署，即可部署成功并投入使用图片步骤"},{"title":"【开源】Web Watermark 图片添加水印在线小助手","url":"/article/Web-Watermark","content":"【开源】Web Watermark 图片添加水印在线小助手 - Web Watermark是一款在线的网页版可离线使用的安全的图片添加水印项目页面截图点击体验项目地址WebWatermark - Github"},{"title":"【开源】HanAnalytics访问分析Web统计托管于（Cloudflare Pages）","url":"/article/han-analytics","content":"【开源】HanAnalytics访问分析Web统计托管于（Cloudflare Pages） - Han-Analytics 是一个简单的网络分析跟踪器和仪表板，托管在被称为赛博菩萨的 Cloudflare 上,无成本稳定运行,每天可达10万次免费统计。域名、服务器、数据库 通通都不用! 托管在 Cloudflare Pages 上即可快速部署网站分析仪表板。页面截图点击体验项目地址HanAnalytics - Github部署登录到 Cloudflare Login，没有的注册一个 Cloudflare SignUp点击 Workers 和 Pages 随便创建一个 workers 并开启 分析引擎，然后复制 workers ID 备用。创建一个 Cloudflare API token 备用。Fork 项目到自己的 Github 账户备用。登录 Cloudflare 并创建 Pages 项目 ，链接Github仓库，选择刚刚 Fork 的项目，架构选择Vue，填入环境变量（环境变量含义如下），部署即可。Cloudflare pages 部署完成后，在项目的设置中配置绑定，添加Analytics Engine，变量名称填写AnalyticsBinding，数据集填写Analyticsdataet并保存，重新部署！。重新部署完成后，访问 https://xxxxxx.pages.dev 即可访问网站分析仪表板。（注意：首次部署生成的域名可能需要几分钟时间生效，请耐心等待）部署成功后，首次打开页面没有数据，请尽快集成到自己的网站并出现有效访问后，再次打开页面即可看到数据！新增 密码访问 及 网站白名单，开启密码后，输入密码可访问（默认无需密码），网站白名单功能，加白的网站才可计入统计（默认任意网站都可统计）环境变量说明# Cloudflare Workers IDCLOUDFLARE_ACCOUNT_ID = 你的 Cloudflare Workers ID# 你的 Cloudflare API tokenCLOUDFLARE_API_TOKEN = 你的 Cloudflare API token# 网站访问密码 (不设置即无需密码访问)CLOUDFLARE_WEBSITE_PWD = # 可统计的白名单 格式：  域名,WebSite|域名,WebSite，多个站点使用|分隔 例如：api.boycot.top,Hello-Han-Api|www.boycot.top,Hello-HanHexoBlog  (不设置即允许任何统计)CLOUDFLARE_WEBSITE_WHITELIST = 绑定# 变量名AnalyticsBinding# 数据集Analyticsdataet集成使用// 在网站底部插入以下代码即可集成网站分析仪表板数据问题一般是由于 Cloudflare Analytics Engine 无法访问网站导致的，请确保网站可以正常访问，并且 Cloudflare Analytics Engine 已经开启。使用 Cloudflare Analytics Engine 数据集，它完全通过 HTTP 使用 Cloudflare 的 API 进行通信，数据完全来源于 Cloudflare Analaytics Engine 数据集中读取Cloudflare Analytics Engine 使用抽样技术，以可承受的规模化方式实现大量数据提取/查询（这类似于大多数其他分析工具，请参阅Google Analytics 上的抽样）。您可以在此处详细了解抽样技术如何与 CF AE 配合使用。"},{"title":"骁龙8Gen3+超声波指纹+2亿像素，魅族旗舰跌至2799元","url":"/article/骁龙8Gen3+超声波指纹+2亿像素，魅族旗舰跌至2799元","content":"骁龙8Gen3+超声波指纹+2亿像素，魅族旗舰跌至2799元 - 在科技与艺术的交汇点上，魅族再次以其独特的视角和精湛的工艺，为我们带来了一款颠覆性的新品——魅族21手机。这款集高性能、高颜值于一身的智能手机，不仅继承了魅族一贯的精致设计和优雅气质，更在硬件配置上进行了全面升级，成为了2023年智能手机市场的一大亮点。魅族21手机，以其无界黑的机身颜色，散发出一种深邃而神秘的气息。它采用了IP54三防标准，无论是细雨绵绵还是意外溅水，都能轻松应对。而机身的轻薄设计，更是让人爱不释手，宽度75.3mm、长度156.7mm、厚度7.9mm的精致尺寸，搭配198g的轻盈重量，即使长时间握持也不会感到疲劳。魅族（MEIZU）21 12GB+256GB 无界黑 1.74mm极窄四等边直屏 骁龙8Gen3 2 ¥2799 京东 购买屏幕方面，魅族21手机采用了6.55英寸的OLED直屏，分辨率高达FHD+，配合E6材质和高达120Hz的刷新率，无论是浏览网页、观看视频还是玩游戏，都能带来极致的视觉体验。而高频PWM调光和SGS认证，则保证了屏幕在低亮度下的舒适性和护眼效果。在拍照方面，魅族21手机同样表现出色。它搭载了2亿像素的后摄主摄像头，配合1300万像素的超广角摄像头和500万像素的景深摄像头，无论是拍摄风景、人像还是微距，都能轻松应对。而前置的3200万像素摄像头，则能满足你自拍和视频通话的需求。在性能方面，魅族21手机搭载了第三代骁龙8移动平台，主频高达3.3GHz，无论是运行大型游戏还是多任务处理，都能轻松应对。而12GB的运行内存和256GB的机身内存，则保证了手机的流畅运行和充足的存储空间。除了硬件配置的全面升级外，魅族21手机在软件方面也进行了优化。它搭载了最新的Android操作系统，支持IPv6和NFC功能，同时还配备了超声波指纹解锁和人脸识别等生物识别技术，让手机的使用更加便捷和安全。魅族21手机以其出色的硬件配置、优雅的外观设计和优秀的软件体验，成为了2023年智能手机市场的一款明星产品。它不仅满足了消费者对于高性能手机的需求，更在细节上展现了魅族对于品质和工艺的执着追求。如果你是一个追求品质生活的消费者，那么魅族21手机绝对是你不可错过的选择。"},{"title":"基于AI的微博动态心情分析【开源】","url":"/article/weibo-dynamic-emotion-analysis-open-source","content":"基于AI的微博动态心情分析【开源】 - 实时关注 Ta 的微博，并了解 Ta 微博动态的情绪心情，通过 Bark 或 PushDeer 进行通知的，基于 Nodejs 的 AI的微博动态心情分析 脚本开源地址WeiBo-Mood免费AI注册配置 config.js 文件module.exports = {  //   AI API接口地址  chatApi: \"https://api.siliconflow.cn/v1/chat/completions\",  //   AI 大模型 (可根据文档更换)  chatModel: \"internlm/internlm2_5-7b-chat\",  //   AI Token  chatToken: \"\",  //   微博ID    https://m.weibo.cn/u/1840274303  WB_UID: \"1840274303\",  //   获取最新微博频率 每间隔16分钟更新一次 (Cron 表达式)  CRON_TIME: \"*/16 * * * *\",  //   Bark通知Token 不填写即不通知  https://bark.day.app/  BARK_TOKEN: \"\",  //   PushDeer通知Token 不填写即不通知  https://www.pushdeer.com/  PUSH_DEER_TOKEN: \"\"};安装依赖npm install运行脚本npm start效果图片"},{"title":"【开源】Cloudflare优选IP➕DnsPod的DDNS自动切换","url":"/article/cloudflare-ip-dnspod-ddns","content":"【开源】Cloudflare优选IP➕DnsPod的DDNS自动切换 - CloudFlare是一个非常优秀的CDN服务，但是CloudFlare也有一个大的毛病——大陆访问速度很慢。国外很多网站都在使用 Cloudflare CDN，但分配给中国内地访客的IP并不友好（延迟高、丢包多、速度慢）。虽然Cloudflare公开了所有IP段，但想要在这么多IP中找到适合自己的，怕是要累死，于是就有了这个脚本。Cloudflare优选IP 每隔15分钟更新(IPv6+IPv4)项目地址CloudflareIP-dnspod-ddns优化后示例站点点击体验实现逻辑及局部代码获取优选IPconst res = await fetch(\"https://api.boycot.top/tool/cf_ip\");const data = await res.json();// 数据格式// {//     \"success\": true,//     \"data\": {//         \"v4\": {//             \"CM\": [],//             \"CU\": [],//             \"CT\": []//         },//         \"v6\": {//             \"CM\": [],//             \"CU\": [],//             \"CT\": []//         }//     }// }取优选IP中的最优选 (延迟比较)// 取最优选IP IPv4const CM_IP_V4 = data.v4.CM.reduce((minItem, currentItem) => {  return currentItem.latency  {  return currentItem.latency  {  return currentItem.latency  {  return currentItem.latency  {  return currentItem.latency  {  return currentItem.latency  {  try {    const res = await client.ModifyRecord({ Domain, RecordType: i.Type, RecordLine: \"\", RecordLineId: i.LineId, Value: i.Type == \"A\" ? DNS_DATA_V4[i.Line] : DNS_DATA_V6[i.Line], RecordId: i.RecordId, SubDomain });    console.log(res);  } catch (error) {    console.log(error);  }});"},{"title":"Markdown Admonitions","url":"/article/Markdown Admonitions","content":"Markdown Admonitions - What are admonitionsAdmonitions (also known as “asides”) are useful for providing supportive and/or supplementary information related to your content.How to use themTo use admonitions in Astro Cactus, wrap your Markdown content in a pair of triple colons :::. The first pair should also include the type of admonition you want to use.For example, with the following Markdown::::noteHighlights information that users should take into account, even when skimming.:::Outputs:Highlights information that users should take into account, even when skimming.Admonition TypesThe following admonitions are currently supported:notetipimportantwarningcautionNote:::noteHighlights information that users should take into account, even when skimming.:::Highlights information that users should take into account, even when skimming.Tip:::tipOptional information to help a user be more successful.:::Optional information to help a user be more successful.Important:::importantCrucial information necessary for users to succeed.:::Crucial information necessary for users to succeed.Caution:::cautionNegative potential consequences of an action.:::Negative potential consequences of an action.Warning:::warningCritical content demanding immediate user attention due to potential risks.:::Critical content demanding immediate user attention due to potential risks.Customising the admonition titleYou can customise the admonition title using the following markup::::note[My custom title]This is a note with a custom title.:::Outputs:My custom titleThis is a note with a custom title."},{"title":"【开源】骤雨重山无限存储图床托管于（Cloudflare Pages）","url":"/article/zycs-img-cloud-from-cloudflare-pages","content":"【开源】骤雨重山无限存储图床托管于（Cloudflare Pages） - 在现代互联网环境中，快速稳定的图片访问是提升用户体验的重要因素之一。本文将介绍如何利用Cloudflare Pages部署稳定的无限图床Imgur，实现图片上传和访问，并进一步通过WordPress的WP.COM全球图片缓存进行加速，提高图片加载速度。可用于免费图片托管解决方案，Flickr 等替代品。简介Cloudflare Pages 是一个强大的静态网站托管服务，结合了 Cloudflare 的全球 CDN（内容分发网络）优势。Imgur 是一个免费优质的图床。WordPress 的全球图片缓存 是一个高效的 CDN 服务，专门用于加速 WordPress 托管的图片内容。它利用全球分布的节点，将图片缓存并提供快速访问。Cloudflare CDN（内容分发网络）是由Cloudflare提供的服务，旨在加速和保护和加速全球网络应用程序。页面点击体验项目地址ZYCS-IMG - Github如何部署1、准备一个 Cloudflare 账户2、Fork 本仓库，自由修改App.vue和index.html文件中的文案3、登录Cloudflare Dashboard打开Workers 和 Pages创建Pages4、连接到Git选择Github或Gitlab中你刚刚Fork的项目，点击开始设置5、只需要修改框架预设为Vue即可，点击保存并部署，即可部署成功并投入使用图片步骤特点无限图片储存数量，你可以上传不限数量的图片到Imgur无需购买服务器，托管于Cloudflare Pages上，每天10万次的请求无需购买域名，可以使用Cloudflare Pages 提供的*.pages.dev的免费二级域名，同时也支持绑定自定义域名"},{"title":"A working draft title","url":"/article/A working draft title","content":"A working draft title - If this is working correctly, this post should only be accessible in a dev environment, as well as any tags that are unique to this post."},{"title":"回到顶部动画算法","url":"/article/回到顶部动画算法","content":"回到顶部动画算法 - 摘自element-ui源码const backTop = () => {    const cubic = value => Math.pow(value, 3)    const easeInOutCubic = value => value  setTimeout(func, 16))    const frameFunc = () => {        const progress = (Date.now() - beginTime) / 500        if (progress < 1) {            el.scrollTop = beginValue * (1 - easeInOutCubic(progress))            rAF(frameFunc)        } else {            el.scrollTop = 0        }    };    rAF(frameFunc)}"},{"title":"Adding Webmentions to Astro Cactus","url":"/article/Adding Webmentions to Astro Cactus","content":"Adding Webmentions to Astro Cactus - TLDRAdd a link on your homepage to either your GitHub profile and/or email address as per IndieLogin’s instructions. You could do this via src/components/SocialList.astro, just be sure to include isWebmention to the relevant link if doing so.Create an account @ Webmention.io by entering your website’s address.Add the link feed and api key to a .env file with the key WEBMENTION_URL and WEBMENTION_API_KEY respectively, you could rename .env.example found in this template. You can also add the optional WEBMENTION_PINGBACK link here too.Go to brid.gy and sign-in to each social account[s] you wish to link.Publish and build your website, remember to add the api key, and it should now be ready to receive webmentions!What are webmentionsPut simply, it’s a way to show users who like, comment, repost and more, on various pages on your website via social media.This theme displays the number of likes, mentions and replies each blog post receives. There are a couple of more webmentions that I haven’t included, like reposts, which are currently filtered out, but shouldn’t be too difficult to include.Steps to add it to your own siteYour going to have to create a couple of accounts to get things up-and-running. But, the first thing you need to ensure is that your social links are correct.Add link(s) to your profile(s)Firstly, you need to add a link on your site to prove ownership. If you have a look at IndieLogin’s instructions, it gives you 2 options, either an email address and/or GitHub account. I’ve created the component src/components/SocialList.astro where you can add your details into the socialLinks array, just include the isWebmention property to the relevant link which will add the rel=\"me authn\" attribute. Whichever way you do it, make sure you have a link in your markup as per IndieLogin’s instructionsGitHubSign up to Webmention.ioNext, head over to Webmention.io and create an account by signing in with your domain name, e.g. https://astro-cactus.chriswilliams.dev/. Please note that .app TLDs don’t function correctly. Once in, it will give you a couple of links for your domain to accept webmentions. Make a note of these and create a .env file (this template include an example .env.example which you could rename). Add the link feed and api key with the key/values of WEBMENTION_URL and WEBMENTION_API_KEY respectively, and the optional WEBMENTION_PINGBACK url if required. Please try not to publish this to a repository!You don’t have to include the pingback link. Maybe coincidentally, but after adding it I started to receive a higher frequency of spam in my mailbox, informing me that my website could be better. TBH they’re not wrong. I’ve now removed it, but it’s up to you.Sign up to Brid.gyYou’re now going to have to use brid.gy. As the name suggests, it links your website to your social media accounts. For every account you want to set up (e.g. Mastodon), click on the relevant button and connect each account you want brid.gy to search. Just to note again, brid.gy currently has an issue with .app TLDs.Testing everything worksWith everything set, it’s now time to build and publish your website. REMEMBER to set your environment variables WEBMENTION_API_KEY & WEBMENTION_URL with your host.You can check to see if everything is working by sending a test webmention via webmentions.rocks. Log in with your domain, enter the auth code, and then the url of the page you want to test. For example, to test this page I would add https://astro-cactus.chriswilliams.dev/posts/webmentions/. To view it on your website, rebuild or (re)start dev mode locally, and you should see the result at the bottom of your page.You can also view any test mentions in the browser via their api.Things to add, things to considerAt the moment, fresh webmentions are only fetched on a rebuild or restarting dev mode, which obviously means if you don’t update your site very often you wont get a lot of new content. It should be quite trivial to add a cron job to run the getAndCacheWebmentions() function in src/utils/webmentions.ts and populate your blog with new content. This is probably what I’ll add next as a github action.I have seen some mentions have duplicates. Unfortunately, they’re quite difficult to filter out as they have different id’s.I’m not a huge fan of the little external link icon for linking to comments/replies. It’s not particularly great on mobile due to its size, and will likely change it in the future.AcknowledgementsMany thanks to Kieran McGuire for sharing this with me, and the helpful posts. I’d never heard of webmentions before, and now with this update hopefully others will be able to make use of them. Additionally, articles and examples from kld and ryanmulligan.dev really helped in getting this set up and integrated, both a great resource if you’re looking for more information!"},{"title":"Example Cover Image","url":"/article/Example Cover Image","content":"Example Cover Image - "},{"title":"A post of Markdown elements","url":"/article/A post of Markdown elements","content":"A post of Markdown elements - This is a H2 HeadingThis is a H3 HeadingThis is a H4 HeadingThis is a H5 HeadingThis is a H6 HeadingHorizontal RulesEmphasisThis is bold textThis is italic textStrikethroughQuotes“Double quotes” and ‘single quotes’BlockquotesBlockquotes can also be nested……by using additional greater-than signs right next to each other…ReferencesAn example containing a clickable reference1 with a link to the source.Second example containing a reference2 with a link to the source.If you check out this example in src/content/post/markdown-elements/index.md, you’ll notice that the references and the heading “Footnotes” are added to the bottom of the page via the remark-rehype plugin.ListsUnorderedCreate a list by starting a line with +, -, or *Sub-lists are made by indenting 2 spaces:Marker character change forces new list start:Ac tristique libero volutpat atFacilisis in pretium nisl aliquetNulla volutpat aliquam velitVery easy!OrderedLorem ipsum dolor sit ametConsectetur adipiscing elitInteger molestie lorem at massaYou can use sequential numbers……or keep all the numbers as 1.Start numbering with offset:foobarCodeInline codeIndented code// Some commentsline 1 of codeline 2 of codeline 3 of codeBlock code “fences”Sample text here...Syntax highlightingvar foo = function (bar) {\treturn bar++;};console.log(foo(5));Expressive code examplesAdding a titleconsole.log(\"Title example\");A bash terminalecho \"A base terminal example\"Highlighting code linesfunction demo() {\tconsole.log(\"this line is marked as deleted\");\t// This line and the next one are marked as inserted\tconsole.log(\"this is the second inserted line\");\treturn \"this line uses the neutral default marker type\";}Expressive Code can do a ton more than shown here, and includes a lot of customisation.TablesOptionDescriptiondatapath to data files to supply the data that will be passed into templates.engineengine to be used for processing templates. Handlebars is the default.extextension to be used for dest files.Table AlignmentItemPrice# In stockJuicy Apples1.99739Bananas1.896Keyboard elementsActionShortcutVertical splitAlt+Shift++Horizontal splitAlt+Shift+-Auto splitAlt+Shift+dSwitch between splitsAlt + arrow keysResizing a splitAlt+Shift + arrow keysClose a splitCtrl+Shift+WMaximize a paneCtrl+Shift+P + Toggle pane zoomLinksContent from markdown-itFootnotesReference first footnote with a return to content link. ↩Second reference with a link. ↩"},{"title":"This post doesn't have any content","url":"/article/This post doesn't have any content","content":"This post doesn't have any content - "},{"title":"Unique tags validation","url":"/article/Unique tags validation","content":"Unique tags validation - This post is to test zod transformIf you open the file src/content/post/unique-tags.md, the tags array has a number of duplicate blog strings of various cases.These are removed as part of the removeDupsAndLowercase function found in src/content/config.ts."},{"title":"Example OG Social Image","url":"/article/Example OG Social Image","content":"Example OG Social Image - Adding your own social image to a postThis post is an example of how to add a custom open graph social image, also known as an OG image, to a blog post.By adding the optional ogImage property to the frontmatter of a post, you opt out of satori automatically generating an image for this page.If you open this markdown file src/content/post/social-image.md you’ll see the ogImage property set to an image which lives in the public folder1.ogImage: \"/social-card.png\"You can view the one set for this template page here.FootnotesThe image itself can be located anywhere you like. ↩"},{"title":"使用Element.animate添加文字与图片动画","url":"/article/使用Element.animate添加文字与图片动画","content":"使用Element.animate添加文字与图片动画 - 在网页添加一些简单的切换动画一般使用 CSS3 的 animation 或者 transition 实现，而 Element.animate 是新的原生 Javascript Api，能使用 JS 快速为 Dom 添加动画。前言为了增加网站的用户体验，在很多场景下一般可以为元素的切换添加一下转场动画。最简单的方法，一般可以使用 CSS 的transition或者animation实现。当前也有很多 CSS 动画库，例如animate.css，它与wow.js搭配使用经常用于很多产品宣传首页。当然我们也可以使用一些主流的 JS 动画库操作某些元素的单独动画，例如：Velocity、Anime.js等。或者更传统的Jquery也有提供.animate操作动画的方案。而本文则介绍一下原生较新的 Javascript Api: Element.animate()关于 Element.animateElement.animate()是Web Animations API提供的使用 Javascript 操作元素动画的解决方案。参数Element.animate(keyframes, options)方法接收 2 个参数，第一个为keyframes，第二个为options。keyframes：与 CSS3 的 keyframes 的概念是一致的，代表关键帧的集合。它可以接收一个关键帧数组，也可以简写成一个对象。它支持所有 CSS 动画支持的属性，另简写写法添加offset, float, easing等关键字 。具体写法请参考Keyframe Formats (MDN)或下文的案例使用。options: 动画的相关配置。其接收delay, duration, easing, iterations等配置参数，可配置动画的延迟执行时间、执行持续时间、缓动曲线、执行次数等，其与 CSS 动画属性也保持一致，更多参数请参考KeyframeEffect (MDN)。这个方法会返回一个Animation实例，通过这个实例我们可以对动画进行暂停、取消、读取执行状态等。或者通过.finished返回 Promise 来对执行完动画进行下一步操作。兼容性因为该 API 较新，所以对传统的浏览器支持并不友好，所有 IE 浏览器都不支持。在Can I use上查询如下：但是只要简单使用if (dom.animate) {}包裹即可向下兼容，对一些不支持的浏览器不执行动画就可以。使用案例文字动画特效简单写了三种文字动画特效：FadeIn：渐变进入FadeUpInOut: 旧文本先淡出新文本再淡入Typewriter: 打字机特效淡入淡出Effect1和Effect2是更改opactity与translate属性实现的文字淡入淡出动画。  // ...省略事件绑定等代码  function animateEffect1(text) {    const target = document.querySelector(\"#Effect1\");    target.innerText = text;    // 使用对象简写写法opactiy from 0, to 1， 执行时间600ms    target.animate({ opacity: [0, 1] }, 600);  }  async function animateEffect2(text) {    const target = document.querySelector(\"#Effect2\");    // finished返回Promise，可等待文本淡出动画执行完再执行新文本淡入动画    await target.animate(      {        opacity: [1, 0],        transform: [\"translateY(0)\", \"translateY(-20px)\"],      },      300    ).finished;    target.innerText = text; // 当旧文本动画执行完再开始替换文本    target.animate(      {        opacity: [0, 1],        transform: [\"translateY(20px)\", \"translateY(0)\"],      },      300    );  }打字机Effect3实现了一个文字打字机特效，该特效需要确保文字是等宽字体，而且文本不能为多行文本。  // ...省略事件绑定等代码  async function animateEffect3(text) {    const target = document.querySelector(\"#Effect3\");    const beforeWidth = target.offsetWidth; // 计算旧文本宽度    const textBeforeLength = target.innerText.length; // 计算文本字数    if (textBeforeLength > 0) {      // 使用数组参数方式执行宽度减少阶跃动画      await target.animate([{ width: `${beforeWidth}px` }, { width: 0 }], {        duration: textBeforeLength * 100,        easing: `steps(${textBeforeLength})`, // step是阶跃函数，表示动画按多少步执行完      }).finished;    }    target.innerText = text; // 切换新文本    const afterWidth = target.offsetWidth; // 计算新文本宽度    const textAfterLength = target.innerText.length; // 计算文本字数    target.animate([{ width: 0 }, { width: `${afterWidth}px` }], {      duration: textAfterLength * 100,      easing: `steps(${textAfterLength})`,    });  }easing属性中使用了steps阶跃函数，它表示动画需要按多少步执行完，每一步状态里面是属性是一致的，每步属性变化是跳跃的，没有过渡。这里使得文本每次减少一个字符的宽度，构造出打字机的效果。以上文字特效的实现已上传到codepen，请参考此处: https://codepen.io/leon-kfd/pen/vYJbodr。图片切换特效在使用 CSS 实现元素动画，一般通过添加类名、移出类名来实现。因为图片无法准确知道需要加载的时间，一般情况是监听图片的 load 事件回调进行判断，所以基本无法使用纯 CSS 来实现切换动画。本次使用原生Element.animate()API 实现了一个简单的图片切换特效。这个特效主要原理：点击切换时，调用函数切换图片路径，这时候图片会异步加载在新图片加载过程中，旧图片执行一个高斯模糊叠加的渐变淡出动画，并把这个 Animation 对象记录下来为图片元素添加 load 事件监听，当图片加载完成，把旧图片淡出动画cancel（因为无法确保旧图片淡出动画执行完前新图片已经加载完成，需要Cancel掉旧动画防止重复执行）执行新图片的高斯模糊淡入动画，动画执行后修改元素 CSS 最终状态Demo 代码如下:Random Img    let leaveAnimation = null; // 用于记录Animation对象  btn.addEventListener(\"click\", () => {    randomPhoto();  });  async function randomPhoto(first) {    const target = `https://source.unsplash.com/random/512x512/?nature,${+new Date()}`;    img.src = target;    // 切换图片路径后，执行图片淡出动画，此时新图片在后台加载    if (!first) {      try {        leaveAnimation = img.animate(          [            { filter: \"blur(20px)\", tarnsform: \"scale(1,1)\" },            { filter: \"blur(60px)\" },          ],          400        );        await leaveAnimation.finished;        img.style.filter = \"blur(60px)\";      } catch {        console.log(\"Cancel animation\");      }    }  }  img.addEventListener(\"load\", async () => {    img.style.opacity = 1; // 用于防止首次加载闪图    if (leaveAnimation) leaveAnimation.cancel(); // cancel掉淡出动画，防止重复执行    const changeAnimation = img.animate(      [        { filter: \"blur(20px)\", tarnsform: \"scale(1,1)\" },        { filter: \"blur(0)\", tarnsform: \"scale(1)\" },      ],      400    );    await changeAnimation.finished;    img.style.filter = \"blur(0)\"; // 等待动画执行完后更改最终状态  });  randomPhoto(true); // 页面加载立即执行一遍以上图片特效的实现已上传到codepen，请参考此处: https://codepen.io/leon-kfd/pen/ZEXYKLR。Demo 中使用了 unsplash 的随机图片接口, https://source.unsplash.com/random另因当前Element.animate()仍属于实验特性，并不保证将来 api 会进行改动或添加新的特性。LinksElement.animate()Text Effect DemoImg Effect Demo"},{"title":"Howdz起始页开发记录","url":"/article/Howdz起始页开发记录","content":"Howdz起始页开发记录 - 前言Howdz是基于Vue3 + Typescript开发的一个完全自定义配置的浏览器导航起始页，支持按需添加物料组件，可自由编辑组件的位置、大小与功能。支持响应式设计，可自定义随机壁纸、动态壁纸等。项目提供网页在线访问、打包出浏览器插件、打包出桌面应用(Electron)等访问方式。本文记录项目开发中使用的相关技术。表单封装项目中运行自由添加各种物料组件，而每一个物料组件都含有自己的配置项表单，而其中又有部分相同的配置项，所以可以实现一个 JS 数据驱动的表单封装。当前使用了ElementPlus框架，封装了一个 StandardForm 组件，为其传入formData与formConf两个属性即可生成双向绑定的表单，支持JSX插入其他自定义组件。因篇幅问题，组件封装代码可参考此处: standard-form.vue然后可以使用类似 JSON 的格式，实现各个物料组件的配置表单，例如Weather组件的setting.tsx如下：// @/materials/Weather/setting.tsximport pick from \"../base\"; // pick可以自由选取公用的配置export default {  formData: {    weatherMode: 1,    cityName: \"\",    animationIcon: true,    duration: 15,    position: 5,    baseFontSize: 16,    textColor: \"#262626\",    textShadow: \"0 0 1px #464646\",    iconShadow: \"0 0 1px #464646\",    fontFamily: \"\",    padding: 10,  },  formConf(formData: Record) {    // 传入formData以实现双向绑定    return {      weatherMode: {        label: \"天气城市\",        type: \"radio-group\",        radio: {          list: [            { name: \"自动获取(IP)\", value: 1 },            { name: \"手动输入\", value: 2 },          ],          label: \"name\",          value: \"value\",        },      },      cityName: {        when: (formData: Record) => formData.weatherMode === 2, // 类似v-if        type: \"input\",        attrs: {          placeholder: \"请输入城市名(目前仅支持中国城市名)\",          clearable: true,        },        rules: [          {            required: true,            validator: (              rule: unknown,              value: string,              callback: (e?: Error) => void            ) => {              formData.weatherMode === 2 && !value                ? callback(new Error(\"请输入城市名\"))                : callback();            },          },        ], // 支持el-form原生rule      },      animationIcon: {        label: \"动画图标\",        type: \"switch\",        tips: \"默认使用含动画的ICON，若想提高性能可关闭使用静态ICON\",      },      duration: {        label: \"自动刷新频率\",        type: \"input-number\",        attrs: { \"controls-position\": \"right\", min: 5, max: 12 * 60 },        tips: \"刷新频率,单位为分钟\",      },      ...pick(formData, [        // 选取公用的配置        \"position\",        \"baseFontSize\",        \"textColor\",        \"textShadow\",        \"iconShadow\",        \"fontFamily\",        \"padding\",      ]),    };  },};右键菜单物料组件添加后，在编辑模式下可以右键弹出菜单更改配置或删除等。右键菜单的实现来源与笔者开源的@howdjs/mouse-menu。同时在本项目中，为了兼容移动端，对插件进行了二次封装，为其添加了长按弹出菜单的功能。二次封装代码参考此处。项目中采用的是vue指令的方式使用，菜单插件可以接收任意参数进行回调，所以可以把点击的物料组件数据传到回调中进行各种操作。       isLock, params: element, menuList }\">              setup () {  \tconst isLock = computed(() => store.state.isLock)  \tconst menuList = ref([  \t\t{ label: '基础配置', tips: 'Edit Base', fn: (params: ComponentOptions) => emit('edit', params.i) },  \t\t{ label: '删除', tips: 'Delete', fn: (params: ComponentOptions) => store.commit('deleteComponent', params) }  \t])  \t// fn中的params为组件数据  }物料组件布局当前提供 2 中布局方式，一种是基于类文件流的栅格布局，这种布局会让组件一个接一个排列，另外一个是 Fixed 布局，可以让组件固定与页面任意位置。栅格模式栅格模式使用vue-grid-layout实现，该插件 vue3 版本处于 Beta 中。                    setup () {  \tconst isLock = computed(() => store.state.isLock)  \tconst list = computed({  \t\tget: () => store.state.list,  \t\tset: (val) => { store.commit('updateList', val) }  \t})  }使用v-model:layout双向绑定栅格模式物料组件列表数据，因为物料数组存在 vuex 中，这里用computed的 setter 进行更新。isLock是用于判断当前是否处于编辑模式，在锁定状态下禁用拖拽与大小更改。当前使用的栅格数为 12，即将屏幕宽度分割为 12 份。Fixed 模式Fixed 模式使用笔者自己开源的@howdjs/to-control插件完成，可以让物料组件固定在页面的任何位置中，也支持拖拽右下角更改大小。   isLock,\t\t\tarrowOptions: { lineColor: '#9a98c3', size: 12, padding: 8 }\t\t}\"    :key=\"element.id\"    @todragend=\"handleAffixDragend($event, element)\"    @tocontrolend=\"handleAffixDragend($event, element)\"  >        setup () {  \tconst isLock = computed(() => store.state.isLock)  \tconst affix = computed(() => store.state.affix)  \tconst handleAffixDragend = ($event: any, element: ComponentOptions) => {  \t\tconst mode = element.affixInfo?.mode || 1  \t\tconst { left, top, bottom, right, width, height } = $event  \t\tconst _element = JSON.parse(JSON.stringify(element))  \t\t_element.affixInfo.x = [1, 3].includes(mode) ? left : right  \t\t_element.affixInfo.y = [1, 2].includes(mode) ? top : bottom  \t\tif (width && height) {  \t\t\t_element.w = width  \t\t\t_element.h = height  \t\t}  \t\tstore.commit('editComponent', _element)  \t}  }与栅格模式不同，这里是使用事件回调函数对组件的 Vuex 数据进行更新。也是使用isLock判断组件是否锁定。插件支持更改定位方向，记录在右上角、右下角等，这样对响应式布局很有效。更多用法可参考: @howdjs/to-control交互弹窗 Popover系统提供一种配置交互行为的功能，可以配置点击一个组件时弹窗另外一个组件，并配置组件弹出的方向。经过调研后发现Element-plus的Popover并不太适合用于这种情况，因为弹出的组件时动态的。于是就自己封装了一个组件，不仅支持配置Popover的各个方向，还另外扩展了一个ScreenCenter的弹出，让组件可以在屏幕中间弹出（类似dialog）。通过传入点击的元素、目标弹窗的宽高和弹窗方向，返回出目标弹窗的x和y。核心代码如下：/** * 获取Popover目标信息 * @param element 来源DOM * @param popoverRect popover信息 * @param direction popover方向 * @returns [endX, endY, fromX, fromY] */export function getPopoverActivePointByDirection(  element: HTMLElement,  popoverRect: PopoverOption,  direction = DirectionEnum.BOTTOM_CENTER) {  const { width, height, top, left } = element.getBoundingClientRect();  const {    width: popoverWidth,    height: popoverHeight,    offset = 10,  } = popoverRect;  const activePointMap = {    [DirectionEnum.SCREEN_CENTER]: [      window.innerWidth / 2 - popoverWidth / 2,      window.innerHeight / 2 - popoverHeight / 2,    ],    [DirectionEnum.TOP_START]: [left, top - popoverHeight - offset],    [DirectionEnum.TOP_CENTER]: [      left + width / 2 - popoverWidth / 2,      top - popoverHeight - offset,    ],    [DirectionEnum.TOP_END]: [      left + width - popoverWidth,      top - popoverHeight - offset,    ],    [DirectionEnum.RIGHT_START]: [left + width + offset, top],    [DirectionEnum.RIGHT_CENTER]: [      left + width + offset,      top + height / 2 - popoverHeight / 2,    ],    [DirectionEnum.RIGHT_END]: [      left + width + offset,      top + height - popoverHeight,    ],    [DirectionEnum.BOTTOM_END]: [      left + width - popoverWidth,      top + height + offset,    ],    [DirectionEnum.BOTTOM_CENTER]: [      left + width / 2 - popoverWidth / 2,      top + height + offset,    ],    [DirectionEnum.BOTTOM_START]: [left, top + height + offset],    [DirectionEnum.LEFT_END]: [      left - popoverWidth - offset,      top + height - popoverHeight,    ],    [DirectionEnum.LEFT_CENTER]: [      left - popoverWidth - offset,      top + height / 2 - popoverHeight / 2,    ],    [DirectionEnum.LEFT_START]: [left - popoverWidth - offset, top],  };  const fromPoint = [left + width / 2, top + height / 2];  return [...activePointMap[direction], ...fromPoint] || [0, 0, ...fromPoint];}另外，使用transform-origin这个属性可以实现弹窗从点击元素过渡展开的动画。最后配置弹窗的方向与弹出的组件类型即可。代码参考：ActionPopover.vue获取任意网站 Favicon在Collection与Search组件中，都有用到一个功能，就是由用户输入网址后能自动获取到网站的 Favicon。在初版实现是直接使用网址 origin + /favicon.ico 获取，但经过大量尝试后发现，当前很多网站的 icon 并不是以这种标准形式存储的。所以后面就自己实现了一个后端接口来获取。后端接口原理:从用户输入的网站中读取到 origin尝试从Redis中读取已缓存的图标路径，读取到则返回若缓存中没有，这使用cheerio加载网站，使用$('link[rel*=\"icon\"]').attr('href')读取图标路径若上一步没有读取到，则继续尝试使用标准形式读取，即网站 Origin + /favicon.ico读取成功则写入Redis缓存，否则返回获取失败同时接口接收type参数，可由后端直接返回图片流，以解决一些网站的 ICON 资源做了 CORS 限制。因为在Collection组件中，为了减少初次访问请求加载数，前端读取到图标后会将图标转成 BASE64 格式存到本地存储中。这种方式需要使用 Ajax 获取图标，让接口直接返回文件流可以解决跨域问题。另读取图标时，前端会使用 Canvas 通道法将图标的白色部分扣成透明，代码可参考此处总结项目仍在持续优化开发中，欢迎各种建议。由于篇幅问题，部分使用到的技术会不定时更新记录。若感谢的可以持续关注、Star，谢谢。相关链接Howdz 介绍文档Github在线网页版地址"},{"title":"利用G渲染器实现的音频可视化方案","url":"/article/利用G渲染器实现的音频可视化方案","content":"利用G渲染器实现的音频可视化方案 - 利用阿里 Antvis 出品的 G 底层图形渲染器，结合 AudioContext 提供的音频数据获取 API，实现出类似网易云播放音频特效。项目地址：⚡Github💡Demo关于 G 渲染器G是一款易用、高效、强大的 2D 可视化渲染引擎，提供 Canvas、SVG 等多种渲染方式的实现。目前，已有多个顶级的可视化开源项目基于G开发，比如图形语法库G2、图可视化库G6等。作为一个底层渲染器，其内置了许多常用的内置图形，提供完整的 DOM 事件模拟，同时提供了流程的动画实现，这些特性对我们这次实现音频特效都是很有必要的。目前与G相似的竞品还有Echart的ZRender，相比较以我个人看法来说，Zrender 提供的 API 更丰富，但是上手难度比 G 要高一点，而G的 API 相对简洁一点。类似的还有老大哥d3，这个相较以上两个更底层，API 更丰富，但上手难度就更大了。同时g里面的一些方法好像也是参考了d3算法思路。G 官方文档 （这里吐槽说一下，G 的官方文档感觉还有很大优化空间，实在太简洁了，很多 API 都是一笔带过，用法也不怎么说明）AudioContext 读取音频数据实现音频特效动画的前提是需要拿到一个音频的音频数据，浏览网上一些方案后，发现AudioContext含有相关的 API。原理：首先需要基于AudioContext.createAnalyser()创建一个Analyser为Analyser关联音频源，目前常用的音频源方式一般为以下两个createMediaElementSource(): 关联到audio或video标签中（当前方案选择了这个）createMediaStreamSource(): 关联到本地计算机或网络音频媒体流对象创建Gain音量节点并关联到Analyser的destination中通过AnalyserNode.getByteFrequencyData()方法将当前频率数据复制到传入的最终需读取音频的 Uint8Array 中把以上操作封装到一个类中，便于初始化，可参考以下代码:// src/plugins/MusicVisualizer.tsconst _analyser = new window.AudioContext();type MusicVisualizerOptions = {  audioEl?: HTMLAudioElement;  size?: number;};export class MusicVisualizer {  private analyser: AnalyserNode;  private gainNode: GainNode;  private audioSource?: MediaElementAudioSourceNode;  private options: MusicVisualizerOptions & {    size: number;  };  private visualArr: Uint8Array;  constructor(options?: MusicVisualizerOptions) {    const defaultOptions = {      size: 128,    };    this.options = {      ...defaultOptions,      ...options,    };    this.analyser = _analyser.createAnalyser();    this.analyser.fftSize = this.options.size * 2;    this.gainNode = _analyser.createGain();    this.gainNode.connect(_analyser.destination);    this.analyser.connect(this.gainNode);    if (this.options.audioEl) {      this.audioSource = _analyser.createMediaElementSource(        this.options.audioEl      );      this.audioSource.connect(this.analyser);    }    this.visualArr = new Uint8Array(this.analyser.frequencyBinCount);    this.resumeAudioContext();  }  // 新版Chrome Audio需要有交互行为后才可以利用JS执行播放  private resumeAudioContext() {    if (_analyser) {      const resumeAudio = () => {        if (_analyser.state === \"suspended\") _analyser.resume();        document.removeEventListener(\"click\", resumeAudio);      };      document.addEventListener(\"click\", resumeAudio);    }  }  // 更换Audio  setAudioEl(el: HTMLAudioElement) {    if (this.audioSource) {      this.audioSource.disconnect(this.analyser);    }    this.audioSource = _analyser.createMediaElementSource(el);    this.audioSource.connect(this.analyser);  }  // 获取音频频域数据  getVisualizeValue() {    this.analyser.getByteFrequencyData(this.visualArr);    return this.visualArr;  }  // 更改音量  changeVolumn(value: number) {    this.gainNode.gain.value = value;  }  // 卸载  destory() {    this.analyser.disconnect(this.gainNode);    this.audioSource?.disconnect(this.analyser);    this.gainNode.disconnect(_analyser.destination);  }}初始化之后，就可以监听 Audio 的播放事件，当播放时利用getVisualizeValue()方法获取到实时音频（可结合利用 requestAnimationFrame 或 setTimeout 获取），这里因为是做可视化动画，当然是利用requestAnimationFrame读取每帧的数据后渲染。还有一个需要注意的点，当 Audio 的数据源是网络音频时，有可能会出现无法读取到音频数据的问题。这个问题一般可能是因为网络音频的跨域限制，需要为 Audio 标签加入crossOrigin=\"anonymous\"属性。一般的 CDN 资源是很少设置 AccessHeader 跨域限制的，但加入这个属性后仍然出现了跨域的报错，说明这网络路径是设置了跨域限制的，这时候可以考虑用 Nginx 反向代理或服务端解决。可视化特效实现以下选取项目部分功能的实现原理进行说明专辑图片旋转动画因为每个示例都需要用到专辑图片旋转动画，因此为了方便把专辑图片的创建抽离了出来。在 G 中画一个圆形图片需要用到Clip，这个在文档中并没有说明，但从 github 中找到了该用法。旋转动画不能直接使用基础属性模拟，这里用到了矩阵变换，利用shape.getMatrix()获取初始矩阵，再通过transform计算出每个ratio对应的矩阵。transform是 G 提供的一个扩展矩阵变换方法，接收 2 个参数，第一个是当前矩阵，第二个参数是 Action 数组。这里的旋转对应的 action 是:['t', -x, -y],['r', 旋转角度],['t', x, y],代码参考如下:import { Canvas } from \"@antv/g-canvas\";import { ext } from \"@antv/matrix-util\";const { transform } = ext; // G提供的矩阵变换快捷方法type ImageCircleConfig = {  x: number;  y: number;  r: number;  shadowColor?: string;};export function getImageCircle(  canvas: Canvas,  { x, y, r, shadowColor }: ImageCircleConfig) {  const shadowConfig = shadowColor    ? {        shadowColor,        shadowBlur: 16,      }    : {};  canvas.addShape(\"circle\", {    attrs: {      x,      y,      r,      fill: \"#262626\",      ...shadowConfig,    },  });  const shape = canvas.addShape(\"image\", {    attrs: {      x: x - r,      y: y - r,      width: 2 * r,      height: 2 * r,      img: `https://source.unsplash.com/random/${2 * r}x${2 * r}?Nature`,    },  });  shape.setClip({    type: \"circle\",    attrs: {      x,      y,      r,    },  });  // 旋转动画  const matrix = shape.getMatrix();  const radian = 2 * Math.PI; // 旋转360度  shape.animate(    (ratio: number) => {      return {        matrix: transform(matrix, [          [\"t\", -x, -y],          [\"r\", radian * ratio],          [\"t\", x, y],        ]),      };    },    {      duration: 10000,      repeat: true,    }  );  // 创建后先暂停动画，等待播放后再恢复  setTimeout(() => {    shape.pauseAnimate();  });  return shape;}在圆上的点示例中经常要计算的就是在圆上的点，以柱状条特效（示例一）为例，首先就是要出围绕着圆的平均 64 个点作为初始坐标。可通过利用当前点与圆心的夹角结合简单三角函数运算出 x,y 的偏移量。如下图, l = cos(θ) * r, t = sin(θ) * r, 通过圆心 O 坐标加上偏移量即可算出点 A 坐标。// POINT_NUM = 64 柱状条数sArr.current = Array.from({ length: POINT_NUM }, (item, index: number) => {  const deg = index * (360 / POINT_NUM) - 150; // 当前角度  const l = Math.cos((deg * Math.PI) / 180); // x方向偏移系数  const t = Math.sin((deg * Math.PI) / 180); // y方向偏移系数  const r = R + OFFSET;  return (canvas.current as Canvas)    .addShape(\"rect\", {      attrs: {        width: RECT_WIDTH,        height: RECT_WIDTH,        radius: RECT_WIDTH / 2,        x: X + l * r - RECT_WIDTH / 2,        y: Y + t * r - RECT_WIDTH / 2,        fill: RECT_COLOR,      },    })    .rotateAtPoint(X + l * r, Y + t * r, ((deg - 90) * Math.PI) / 180);});这里每个柱状条都需要进行旋转来围绕圆排列，使用的是rotateAtPoint绕着初始点旋转对应角度。基本所有的示例都需要首先计算出围绕圆的点坐标，都是采用这种方式计算即可。使用 Path 绘制圆形某些场景下需实现一些类圆动画（示例二、三等），但圆形是无法实现这种动画的，这时候可以采用 Path 实现。在初始状态未进行播放时，默认会显示一个圆形，这是为了减少创建一个圆的实例，可以直接利用 Path 绘制出圆形，后续的动画直接更改这个 Path 实例。可以使用 2 个圆弧生成生成一个圆形的 Path， 参考以下代码export function getCirclePath(cx: number, cy: number, r: number) {  return `M ${cx - r}, ${cy}  a ${r}, ${r} 0 1, 0 ${r * 2}, 0   a ${r}, ${r} 0 1, 0 ${-r * 2}, 0`;}通过点形成平滑曲线若仅仅是将目标一组点连接成线，在视觉效果上会显得很突兀，及时改换成 Path 来连接成曲线也是不够平滑。这时候可以采用插值法为连续目标点再插入中间点来为 Path 更加平滑，一般来说都是采用三次样条插值算法实现。在 d3 中内置了很多连线算法方案，可以直接采用。在本次的示例中，遇到多个点生成平滑曲线的都是采用了 d3 的curveCardinalClosed算法来生成 Path 路径。// s-path.tsximport { line, curveCardinalClosed } from \"d3\";// some other code...useEffect(() => {  if (props.data?.length) {    const pathArr: any[] = [[], [], [], []];    getArray(props.data).map((item, index) => {      pathArr[index % 4].push(        getPointByIndex(index, ((item * item) / 65025) * POINT_OFFSET + 4)      );    });    pathArr.map((item, index) => {      // 使用d3的curveCardinalClosed为目标点数组插值生成平滑曲线Path      const path = line()        .x((d: [number, number]) => d[0])        .y((d: [number, number]) => d[1])        .curve(curveCardinalClosed)(item);      sPathArr.current[index]?.attr(\"path\", path);    });  }}, [props.data]);d3其他平滑曲线算法示例可参考笔者在很久以前写的 Demo: Click here在圆上的点跟随圆放大的同时做圆周运动示例五中的动画会出现在圆上的点跟随圆放大的同时做圆周运动，这种动画在实现时有两种方案：第一种，是大圆利用 Path 模拟，然后动画开始后在每帧动画中，利用Path.getPoint(ratio: number)获取当前大圆中点当前帧下某个对应点的坐标。第二种，是直接计算出当前帧下这个点在圆上的位置，利用三角函数结合大圆的放大偏移系数与ratio即可计算出当前点坐标。在实现第一种方案时，发现效果不太理想，不知道是不是有 setTimeout 的原因，弃用了然后选择了方案二实现。部分参考代码如下:Array.from({ length: CIRCLE_NUM }, (item, index) => {  circleArrStart.current.push(false);  // circle大圆  circleArr.current.push(addCircle());  circleArr.current[index].animate((ratio: number) => {    return {      r: R + ratio * CIRCLE_SCALE_OFFSET,      // path: getCirclePath(X, Y, R + ratio * 80),      opacity: ratio > 0.02 && ratio  {    if (props.data && ratio  0.9) {      circleDotDegArr.current[index] = 0;    }    const deg = circleDotDegArr.current[index] + ratio * 360 - 180;    const l = Math.cos((deg * Math.PI) / 180);    const t = Math.sin((deg * Math.PI) / 180);    const r = R + ratio * CIRCLE_SCALE_OFFSET;    return {      x: X + l * r,      y: Y + t * r,      r: DOT_R * (1 - ratio / 2),      opacity: ratio > 0.05 && ratio  {  Array.from({ length: PARTICLE_NUM }, (particle, index2) => {    const deg = index1 * (360 / POINT_NUM) - 150 + (Math.random() - 0.5) * 10;    const l = Math.cos((deg * Math.PI) / 180);    const t = Math.sin((deg * Math.PI) / 180);    const r = R + OFFSET;    const x = X + l * r;    const y = Y + t * r;    const particleShape = (canvas.current as Canvas).addShape(\"circle\", {      attrs: {        x,        y,        r: 0.8,        fill: \"#fff\",        opacity: 0,        // ⚠开启阴影会掉帧        // shadowColor: '#fcc8d9',        // shadowBlur: 1      },    });    particleShape.animate(      (ratio: number) => {        const deg = index1 * (360 / POINT_NUM) - 150 + Math.sin(ratio * 20) * 4;        const l = Math.cos((deg * Math.PI) / 180);        const t = Math.sin((deg * Math.PI) / 180);        const _index = POINT_NUM * index1 + index2;        if (particleActiveArr.current[_index]) {          if (ratio = currentActiveIndex.current - 1 &&              index1  0.98) {            particleActiveArr.current[_index] = POINT_MOVE_LENGTH;          }        }        const offset = particleActiveArr.current[_index] || POINT_MOVE_LENGTH;        return {          x: x + l * ratio * offset,          y: y + t * ratio * offset,          opacity: 1 - ratio,        };      },      {        duration: POINT_CREATE_DELAY,        repeat: true,        easing: \"easeSinInOut\",      }    );    particleArr.current.push(particleShape);    particleStartArr.current.push(false);    particleActiveArr.current.push(POINT_MOVE_LENGTH);  });});其他说明这个项目是一个练手项目，基于vite、React、Typescript，因为 react 平时用的不多，项目中存在什么问题或写的不好的地方欢迎指点。或者有什么好看的特效也可以提 ISSUE 或 PR 交流一下怎么实现。项目 Github: Click Here项目 Demo: Click Here"},{"title":"Vue3实现自定义右键菜单","url":"/article/Vue3实现自定义右键菜单","content":"Vue3实现自定义右键菜单 - 使用 Vue3 实现自定义鼠标右键菜单，支持二级菜单、自定义样式、回调函数等功能，同时提供封装成 Vue 指令调用。🚀 初步构思仅用 Vue 构建右键菜单 UI 组件，需利用组件提供 show 方法唤起菜单，在指令中再封装对右键菜单事件的处理接收一个菜单项数组配置，菜单项中提供点击菜单后回调函数，可以自定义传入回调函数的参数将菜单 DOM 中的样式尽量抽离出可配置，并利用 CSS 变量注入，可自定义菜单的样式提供show方法接收x,y定位参数，然后显示菜单，同时要加入检查窗口碰撞后的处理由于右键菜单的特殊性，可封装组件为单实例，页面上只会存在一个菜单实例，可优化性能🌈 功能说明菜单项列表-menuListmenuList作为必传参数，用于渲染出菜单项，接收一个长度至少为 1 的数组，同时可以指定children属性用于渲染二级菜单。菜单项中的配置尽量做成同时接收函数的方式，以便可以通过传入的参数更快动态配置出不同的菜单。当前支持以下菜单项配置:参数说明类型fn点击菜单后执行的回调,回调参数 1 为用户传入的 params, 参数 2 为点击右键时所在的 HtmlElement 元素（使用 document.elementFromPoint 获取）, 参数 3 为指令绑定的当前元素(params, activeEl, bindingEl) => voidlabel菜单名, 可使用函数，回调参数同 fn 选项String, Functiontips菜单辅助文本（处于右侧的文本），可使用函数，回调参数同 fn 选项String, Functionicon菜单图标的类名（字体图标)Stringhidden菜单项是否隐藏，可使用函数，回调参数同 fn 选项Boolean, Functiondisabled菜单项是否不可点击，可使用函数，回调参数同 fn 选项Boolean, Functionchildren子菜单的菜单项数组（配置与此表一致，但目前仅支持二级菜单）Arrayline是否为分割线,该值为 True 时,以上设置均失效Boolean菜单在每次打开时都会调用以下方法去格式化出最终的菜单项:const formatterFnOption = (  list: MenuSetting[],  clickDomEl: HTMLElement,  el: HTMLElement,  params: any): MenuSetting[] => {  return list.map((item) => {    if (item.children) {      // 对子菜单进行递归处理      item.children = formatterFnOption(item.children, clickDomEl, el, params);    }    if (isFunction(item.label)) {      item.label = item.label(params, clickDomEl, el);    }    if (isFunction(item.tips)) {      item.tips = item.tips(params, clickDomEl, el);    }    if (isFunction(item.hidden)) {      item.hidden = item.hidden(params, clickDomEl, el);    }    if (isFunction(item.disabled)) {      item.disabled = item.disabled(params, clickDomEl, el);    }    return item;  });};Example: 基础菜单窗口碰撞处理菜单弹出时根据传入的坐标当作左上角定位，此时需要检测它是否碰撞到了窗口，当传入坐标加上菜单宽度或高度超出了窗口最大宽高时要进行调整。const show = async (x = 0, y = 0) => {  // ...some other code  await nextTick();  // 以下代码检测是否碰撞到了窗口  const { innerWidth: windowWidth, innerHeight: windowHeight } = window;  const menu = MenuWrapper.value;  const menuHeight = menu.offsetHeight;  const menuWidth = props.menuWidth || 200;  menuLeft.value =    x + menuWidth + 1 > windowWidth ? windowWidth - menuWidth - 5 : x + 1;  menuTop.value =    y + menuHeight + 1 > windowHeight ? windowHeight - menuHeight - 5 : y + 1;};因为二级菜单是悬停后才出现的，所以二级菜单的碰撞检测需同样额外去处理。const handleMenuMouseEnter = ($event: MouseEvent, item: MenuSetting) => {  if (item.children && !item.disabled) {    hoverFlag.value = true;    const el = $event.currentTarget as HTMLElement;    if (!el) return;    const { offsetWidth } = el;    const subEl = el.querySelector(\".__menu__sub__wrapper\") as HTMLElement;    if (!subEl) return;    // 以下代码检测是否碰撞到了窗口    const { offsetWidth: subOffsetWidth, offsetHeight: subOffsetHeight } =      subEl;    const { innerWidth: windowWidth, innerHeight: windowHeight } = window;    const { top, left } = el.getBoundingClientRect();    if (left + offsetWidth + subOffsetWidth > windowWidth - 5) {      subLeft.value = left - subOffsetWidth + 5;    } else {      subLeft.value = left + offsetWidth;    }    if (top + subOffsetHeight > windowHeight - 5) {      subTop.value = windowHeight - subOffsetHeight;    } else {      subTop.value = top + 5;    }  }};Example: 二级菜单自定义样式菜单样式通过 CSS3 变量控制，通过menuWrapperCss和menuItemCss两个 Props 传入修改 CSS 变量。let el = MenuWrapper.value;if (props.menuWrapperCss) {  Object.keys(props.menuWrapperCss).map((item) => {    el.style.setProperty(      `--menu-${item}`,      props.menuWrapperCss && props.menuWrapperCss[item]    );  });}if (props.menuItemCss) {  Object.keys(props.menuItemCss).map((item) => {    el.style.setProperty(      `--menu-item-${item}`,      props.menuItemCss && props.menuItemCss[item]    );  });}支持的样式如下:menuWrapperCss-菜单容器CSS设置（点击展开查看）参数说明类型默认值background菜单容器背景色String#c8f2f0boxShadow菜单容器阴影String0 1px 5px #888padding默认 paddingString5px 0borderRadius圆角String4pxlineColor分割线颜色String#ccclineMargin分割线 MarginString5px 0menuItemCss-菜单项CSS设置（点击展开查看）参数说明类型默认值height每项高度String30pxpadding-String0 10pxiconSize图标大小String20pxiconFontSize字体图标字体大小(设置类型为字体图标时可用)String-iconColor字体图标颜色String#484852labelColor菜单项标题颜色String#484852labelFontSize菜单项标题字体大小String14pxtipsColor菜单辅助文字颜色String#889tipsFontSize菜单辅助文字字体大小String12pxarrowColor指示箭头颜色（出现子菜单时生成）String#484852arrowSize指示箭头大小（指示箭头为使用 border 生成的三角形)String10pxdisabledColor菜单禁用状态时的颜色String#bcchoverBackgroundhover 时菜单项的背景色Stringrgba(255,255,255,.8)hoverLabelColorhover 时菜单项 label 的颜色StringnullhoverTipsColorhover 时菜单项 tips 的颜色StringnullhoverArrowColorhover 时菜单项 arrow 的颜色StringnullExample: 自定义样式对于不支持 CSS 变量的浏览器也可以选择覆盖 CSS 类名实现⚡ 封装成函数调用当前只是用 Vue 构建了菜单组件，但并不推荐直接使用组件方式引用。为了方便使用将其封装出一个函数，在需要使用时再调用函数，这种类似ElementUI的MessageBox的调用方式。同时函数调用方式可确保页面上只会存在一个菜单实例，可优化性能。函数调用方式必须在 options 中传入 el（绑定唤起菜单的 Dom 元素）。function CustomMouseMenu(options: CustomMouseMenuOptions) {  const className = \"__mouse__menu__container\";  let container: HTMLElement;  if (document.querySelector(`.${className}`)) {    container = document.querySelector(`.${className}`) as HTMLElement;  } else {    container = createClassDom(\"div\", className);  }  const vm = h(MouseMenu, options);  render(vm, container);  document.body.appendChild(container);  return vm.component?.proxy as ComponentPublicInstance;}Example: CustomMouseMenu 函数调用方式🔥 封装成 Vue3 指令方式调用因为使用指令可以提前知道菜单要绑定到哪个 Dom 元素中，把右键及 contextmenu 事件的处理封装在 vue 指令中，使用 Vue 指令可以更方便的调出菜单。Vue 指令也是本插件最推荐的方法。因为移动端下的 contextmenu 行为不一致，我们可以采用长按事件代替。在指令封装中，同时做了 PC 端右键唤起与移动端长按唤起菜单的处理。指令实现原理主要是利用传入的参数与绑定的 Dom 等参数，封装用户的右键与长按事件并利用CustomMouseMenu函数唤出菜单。查看源码指令方式使用如下：  Dom  import { MouseMenuDirective } from \"@howdyjs/mouse-menu\";  export default {    directive: {      MouseMenu: MouseMenuDirective,    },    setup() {      return {        options: {}, // Some Options      };    },  };备注说明为了性能，指令封装模式默认只对 mounted 钩子进行挂载。当使用场景中有 params 参数传入菜单函数，有可能需要在组件更新时更新菜单，这时可以同时把 update 也挂载上。可参考以下写法:import { MouseMenuDirective } from \"@howdyjs/mouse-menu\";export default {  directive: {    MouseMenu: {      ...MouseMenuDirective,      updated: MouseMenuDirective.mounted,    },  },};🌟ElementPlus table 中使用右键菜单比较常用的一个场景是在表格中右键列表项弹出菜单，并通过列表项数据显示不同的菜单。以下提供一个 Vue 指令方式操作原生表格的 Example:Example: 指令方式绑定到原生表格由于ElementPlusUI 库中的el-table提供了row-contextmenu方法，这样可以很方便的让我们的右键菜单扩展到 el-table 中。只要对row-contextmenu方法进行处理，就可以在 el-table 中实现右键弹出菜单功能。showMouseMenu(row, column, event) {  const { x, y } = event  const ctx = CustomMouseMenu({    el: event.currentTarget,    params: row,    ...this.menuOptions  })  ctx.show(x, y)  event.preventDefault()}Example in ElementPlusTable: Demo✨ 其他说明插件还支持其他配置，例如菜单图标，禁用模式等。配置参数（Props/指令 Value）：参数说明类型默认值el触发的 Dom 元素（以 Vue 组件方式或 CustomMenu 函数方式使用时必须传入）--menuWidth菜单宽度Number200menuList生成菜单项的数组，具体配置参考下表Array-hasIcon是否有菜单图标BooleanfalseiconType菜单图标的类型(目前仅支持字体图标)Stringfont-iconmenuWrapperCss菜单容器的 CSS 设置，具体配置参考下表Object-menuItemCss菜单项的 CSS 设置，具体配置参考下表Object-params传给处理函数的自定义参数，会注入到下方各回调函数的首个参数中any-appendToBody容器是否挂载到 body 上Booleantruedisabled是否禁用整个菜单，接收一个函数(params: any) => boolean-useLongPressInMobile移动端下兼容使用长按事件唤出菜单, 但长按模式不支持多级菜单（仅支持指令方式）BooleanfalselongPressDuration长按事件需持续时间,单位 msNumber500injectCloseListener自动注入关闭菜单的 Listener，设为 false 时需自行处理Booleantrue该插件收录在howdyjs中，为其一个分包，欢迎 start🔗LinksGithubDemo"},{"title":"Dashboard自定义面板项目介绍","url":"/article/Dashboard自定义面板项目介绍","content":"Dashboard自定义面板项目介绍 - 项目介绍Dashboard 是一个笔者基于Vite + Vue3 + Typesript开发的项目，个性化的浏览器导航首页面板，支持自定义添加组件，可编辑组件各种属性。响应式设计，可自定义随机壁纸背景图。⚡Github💡Demo功能特性✨ 组件长度单位面板可基于响应式设计布局，添加组件时可选择FR单位，FR 单位会基于当前屏幕宽度动态计算出组件宽度。当然也可以使用PX固定长度单位，一般建议是宽度使用FR而高度使用PX。💫 布局模式当前提供两种布局模式，默认布局是基于文档流的，使用vuedraggable可拖拽改变组件顺序。另一种是Fixed模式，是基于 Fixed 定位的，使用@howdyjs/to-drag拖拽改变位置。🍭 编辑模式添加的组件含有较多配置可自定义，不限于背景颜色、阴影、字体颜色大小与组件属性等。点击右下方菜单解除锁定后即可进入编辑模式，编辑模式下通过右键点击组件即可弹出菜单进行编辑（移动端下是长按弹出菜单），右键菜单基于@howdyjs/mouse-menu。🍌 数据同步点击右下方辅助功能进入导入导出面板，现在支持两种同步方式，一种是生成随机码进行同步，另一种是导出JSON文件进行同步。后续有可能考虑会添加账户功能进行同步。🎉 默认主题当前首次进入网站，会弹出默认主题选择，用户可先选择一种默认主题再进行二次创作。🌟 随机图片与动态壁纸网站背景图与组件背景可以设置使用随机图片，图片来源于Unsplash的随机图片，可选自定义关键词，并提供了可选的国内镜像加速（由多吉提供，服务暂未稳定）。最新已加入动态壁纸的支持，选择背景图时选择网络图片后输入一个网络视频路径即会识别成动态壁纸。🌈 多种物料组件当前提供了多种物料组件，例如时钟、天气、搜索栏等，后面会陆续添加更多的组件。组件引入采用按需加载，没有使用的组件不会在初始化时加载。物料组件Empty: 占位区块组件，支持一些简单配置与自定义文本Clock: 时钟组件Verse: 随机古诗组件，API 来源于https://www.jinrishici.com/Search: 搜索栏，支持自定义搜索引擎，按 Tab 键自动切换下一个，关键词联想Collection: 键盘收藏夹，设置网站后按相应按键自动跳转，网站 Icon 自动获取Iframe: Iframe 外部网站，最新版浏览器只支持同协议(当前网站为 https)的 IframeTodoList: 备忘清单，可同时设置不同日期Weather: 天气组件，支持通过 IP 自动获取城市也可手动输入，后续考虑添加读取 GPSCountDown: 倒计时组件，支持天、小时、分钟三种单位JuejinList: 掘金组件，显示最新热门列表WeiboList：微博热搜GithubTrending: Github 趋势，显示当日热门仓库项目相关StandardForm 表单封装项目中使用了ElementPlus框架，为了减轻代码量与抽离复用逻辑，封装了一个 StandardForm 组件，可以使用 jsx 文件生成 Element 表单。各物料组件需提供一个自己的 setting.tsx 文件为该组件的配置，同时将可复用的配置项抽离出来。例如： Weather 组件的 setting.tsx// @/materials/Weather/setting.tsximport pick from \"../base\";export default {  formData: {    weatherMode: 1,    cityName: \"\",    duration: 15,    position: 5,    baseFontSize: 16,    textColor: \"#262626\",    textShadow: \"0 0 1px #464646\",    iconShadow: \"0 0 1px #464646\",    fontFamily: \"\",    padding: 10,  },  formConf(formData: any) {    return {      weatherMode: {        label: \"天气城市\",        type: \"radio-group\",        radio: {          list: [            {              name: \"自动获取(IP)\",              value: 1,            },            {              name: \"手动输入\",              value: 2,            },          ],          label: \"name\",          value: \"value\",        },      },      cityName: {        when: (formData: any) => formData.weatherMode === 2,        type: \"input\",        attrs: {          placeholder: \"请输入城市名(目前仅支持中国城市名)\",          clearable: true,        },        rules: [          {            required: true,            validator: (rule: any, value: any, callback: Function) => {              if (formData.weatherMode === 2 && !value) {                callback(new Error(\"请输入城市名\"));              }              callback();            },          },        ],      },      duration: {        label: \"自动刷新频率\",        type: \"input-number\",        attrs: {          \"controls-position\": \"right\",          min: 5,          max: 12 * 60,        },        tips: \"刷新频率,单位为分钟\",      },      ...pick(formData, [        \"position\",        \"baseFontSize\",        \"textColor\",        \"textShadow\",        \"iconShadow\",        \"fontFamily\",        \"padding\",      ]),    };  },};formConf 需要传入一个参数为 formData 函数以作为 vModel 的双向绑定字体选择器组件有一个公用的属性是设置字体，需要获取到用户系统的自带字体列表。参考《小 tips: 使用 JS 检测用户是否安装某 font-family 字体》（张鑫旭）后，抽离出判断getSupportFontFamilyList方法。原理是利用 canvas 画出设置后的字体，看它是否与默认字体生成的一样，如果一样则说明不支持，不一样说明新字体设置生效，用户支持该字体。同时后面有可能考虑加入Google Font支持自定义字体。Todo更多的物料组件Service worker 存储图片缓存（已完成)Chrome extension 添加浏览器插件模式（已完成）Electorn 桌面应用模式（已完成）项目仍在持续开发及优化中，若文章或项目中有做的不好的地方欢迎指出，不胜感激。⚡Github💡Demo"},{"title":"开发Online Code Editor过程的一些记录","url":"/article/开发Online Code Editor过程的一些记录","content":"开发Online Code Editor过程的一些记录 - OnlineCodeEditor 是笔者基于 Vue3 + Typescript 开发的一个类似Codepen的开源项目，本文记录一些项目中使用到技术及实现原理等。🏹Github🌈Simple Demo from Github pages🎉Simple Demo from author serverFeature✅ 纯前端项目静态部署（利用 iframe 与postMessage生成实时预览子页）✅ 响应式布局，布局可弹性伸缩支持拖拽更改宽度、折叠。✅ HTML/CSS Emmet技术，按Tab键快速生成代码✅ 支持引入外部 CDN 样式和 JS.✅ 增加SCSS解析模块. (基于在线转换 API：sassmeister.com)主要原理使用codemirror搭建 HTML、CSS、JS 三种代码块编译器，构建一个 Iframe 网页用于展示效果。然后利用Postmessage向 Iframe 传入代码数据并替换旧代码。同时支持传入 jsCDN 与 CssCDN 路径，也是利用新增或更新动态标签实现。注意为了防止一直更改 dom 浪费内存，我们可以使用debounce防抖等让其在代码停止编辑一定时间才进行刷新。通过简单的改写 html/css/js 实现不刷新页面更新页面效果。function loadPage(htmlCode, cssCode, jsCode) {  const _html = document.querySelector(\"#customHTML\");  if (_html) document.body.removeChild(_html);  const html = document.createElement(\"div\");  html.id = \"customHTML\";  html.innerHTML = htmlCode;  document.body.appendChild(html);  const _css = document.querySelector(\"#customCSS\");  if (_css) document.head.removeChild(_css);  const css = document.createElement(\"style\");  css.id = \"customCSS\";  css.innerHTML = cssCode;  document.head.appendChild(css);  const _script = document.querySelector(\"#customJS\");  if (_script) document.body.removeChild(_script);  const script = document.createElement(\"script\");  script.id = \"customJS\";  script.innerHTML = jsCode;  document.body.appendChild(script);}当然有一些场景是需要手动刷新页面的，例如：添加 JS 监听器、更新 CDN 路径等。这时为 iframe 更新时间戳，就可以实现页面刷新。async function sendMessage(refresh = false) {  if (refresh) {    state.iframeURL.value = `./iframe.html?t=${+new Date()}`    await new Promise((resolve) => {      setTimeout(() => {        resolve(1)      }, 2000)    })  }  ...}Emmetemmet技术，可以让开发者速写 html 代码。官方文档参考：https://docs.emmet.io/emmet 有提供 npm 包，可以让我们在浏览器中使用其 API。import expand from \"emmet\";// 传入word与模式即可获取到速写后的代码const result = expand(word, { type: mode });同时需要注意，在编写代码时，我们需要提取出速写前的单词，我们可以以空格为界限进行切割，可参考以下函数function getWord(line: string, ch: number): [string, number] {  const getNearTagChar = (str: string): string => {    for (let i = str.length - 1; i > 0; i--) {      if (str[i] === \">\" || str[i] === \" ch + 1 && (/\\s/.test(line[ch]) || line[ch] === \"= 0; i--) {      if (        /\\s/.test(line[i]) ||        (line[i] === \">\" && getNearTagChar(line.slice(0, i)) === \" {    config.plugin(\"html-index\").tap((args) => {      args[0].cdn = assetsCDN;      return args;    });  },  css: {    loaderOptions: {      scss: {        prependData: '@import \"~@/assets/variable.scss\";',      },    },  },  productionSourceMap: !isProduction,  publicPath,};兼容手机模式（响应式设计)项目中代码编辑器布局在 PC 端中支持自定义拉伸与折叠，使用了笔者开源插件@howdyjs/resize。实现响应式设计一般采用 CSS3 的媒体查询实现，但由于布局问题，手机端下不适用拉伸布局，需要额外添加一个手机端下的标签页，所以这次需要使用 js 辅助实现。利用 Github Workflows 实现自动构建由于该项目是纯前端项目，打包后直接部署就行，所以很适合使用 github page 部署。使用 Github workflows 可以构建任务，让其在代码 push 时自动执行打包，并部署到 github page 分支。目前已经社区已经有很多成熟的常用任务，不需要自己编写。这次主要用到了github-pages-deploy-action可以直接帮我们把代码发布到 github page 分支。# .github/workflows/main.deploy.ymlname: Deploy Doc Websiteon:  push:    branches:      - mainjobs:  main-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@v2        with:          persist-credentials: false      - name: Setup node        uses: actions/setup-node@v2      - name: Install dependencies        run: yarn      - name: Build Demo        run: yarn build:hash      - name: Deploy        uses: JamesIves/github-pages-deploy-action@3.7.1        with:          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}          BRANCH: gh-pages          FOLDER: dist需要注意 github page 目前不支持history的路由模式Todo😴 Javascript Babel 模式😴 引入账号系统同步代码😴 线上代码展示模式"},{"title":"Howdyjs组件库迁移Vue3设计与总结","url":"/article/Howdyjs组件库迁移Vue3设计与总结","content":"Howdyjs组件库迁移Vue3设计与总结 - 将个人组件库 Howdyjs 使用 Vue + Typescript 进行重构，使用 Vite 构建开发站点，Rollup 进行组件打包并分包发布 NPM。Link⚡Github📖Document💾NPM主要变更新版全面采用TypescriptVue 组件部分将使用Vue3重构，不向下兼容，有 Vue2.X 需求的请使用旧版因各组件内的关联性不强，新版的组件库将进行分包发布，可便于按需加载旧版多数包都将功能封装成 Vue 指令，并默认导出的是 Vue 指令，现在新版将默认导出原生构造函数，便于跨框架或原生使用，但同时保留了 Vue 指令封装的使用方式使用lerna进行分包管理使用Rollup进行组件打包展示站点使用Vite搭建架构说明Vite综合对比之后，发现采用 Vite 基本可以实现当前展示站点的所有功能，而且在开发环境下热更新速度极快，所以新版项目采用了 Vite 构建开发站点。由于项目有导入.md 文件的需求，而 Vite 并不能直接使用 Webpack 的 markdown-loader，所以暂时自己写一个简单的 markdown-plugin 在 Vite 中使用// vite.config.tsconst markdownPlugin = (options: any) => {  return {    name: \"markdown\",    transform(code: string, id: string) {      if (!/\\.md/.test(id)) {        return;      }      const result = marked(code, options);      return `export default ${JSON.stringify(result)}`;    },  };};export default {  plugins: [    vue(),    markdownPlugin({      highlight: (code: string) => {        if (code.includes(\"template\")) {          return hljs.highlight(\"html\", code).value;        } else if (code.includes('lang=\"ts\"')) {          return hljs.highlight(\"typescript\", code).value;        } else {          return hljs.highlightAuto(code).value;        }      },    }),  ],};Vite 新版文档地址: https://vitejs.dev/LernaLerna 是一个项目内包管理工具，虽然当前项目内的组件关联性不强，但也提前先引入了 Lerna 进行分包管理。执行npm run bootstrap命令进行项目初始化.执行npm run publish命令可快速发包Rollup 打包组件使用 Rollup 进行打包，执行npm run build:pkg打包各 Packages，包含 cjs、es 和其 d.ts 文件。使用 nodejs 执行 rollup 打包，代码位于/scripts 下，build.js 为打包初始模板，一个组件会被打包出 3 种格式：cjs/esm/umd，格式说明参考格式Vue 路由自动生成使用 Vite 打包时，Vue 路由懒加载是基于 Rollup 的动态引入插件的，它对我原站点的格式不太适用。而由于展示站点中，各个路由格式是具有一定通用性的，所有采用了一种读取文件目录自动生成路由文件的方式。// scripts/gen-route.js// 自动生成路由文件const fs = require(\"fs\");const packagesDirs = fs.readdirSync(\"./src/pages\");const packagesMap = {};packagesDirs.map((package) => {  const exampleDirs = fs.readdirSync(`./src/pages/${package}/example`);  const exampleNum = exampleDirs.length;  packagesMap[package] = exampleNum;});const packages = Object.keys(packagesMap).map((key) => {  return {    name: key,    exampleNum: packagesMap[key],  };});const routes = [  {    path: \"/\",    name: \"home\",    component: \"i(../views/home.vue)\",  },  ...packages.map((pkg) => {    const { name, exampleNum } = pkg;    return {      path: `/${name}`,      name: `${name}`,      redirect: `/${name}/readme`,      component: `i(../pages/${name}/index.vue)`,      children: [        {          path: `/${name}/readme`,          name: `${name}-readme`,          component: \"i(../components/PageReadme.vue)\",        },        ...Array.from({ length: exampleNum }, (_, exampleIndex) => {          return {            path: `/${name}/example${exampleIndex + 1}`,            name: `${name}-example${exampleIndex + 1}`,            component: `i(../pages/${name}/example/example${              exampleIndex + 1            }.vue)`,          };        }),      ],    };  }),];const reg = /\"i\\((.*?)\\)\"/g;const routesStr = JSON.stringify(routes, null, 2).replace(  reg,  (...arg) => `() => import(\"${arg[1]}\")`);const output = `/* eslint-disable */import { createRouter, createWebHistory } from 'vue-router';const router = createRouter({  history: createWebHistory('/howdy/'),  routes: ${routesStr}});export default router;`;fs.writeFileSync(\"./src/router/index.ts\", output);执行命令npm run gen-router后，会自动读取/packages 下的包文件，然后生成出对应的路由。说明新版地址: Howdy旧版地址: Howdy-old使用的是同一个 github 仓库，新版参考master 分支，旧版参考howdy 分支"},{"title":"使用D3.js将离散的点形成平滑曲线及其应用","url":"/article/使用D3.js将离散的点形成平滑曲线及其应用","content":"使用D3.js将离散的点形成平滑曲线及其应用 - 前言之前遇到了一个场景，需要将多个离散的点使用一条平滑的曲线连起来。在网上找了很多方案，一般都是说使用**三次样条插值**实现。自己参考网上算法写了下，发现效果不太理想。然后看到 D3js 官方原来直接内置了多种相关算法，但官方并没有提供效果展示，于是就编写了一个简单的可以快速看到各种连线算法的效果图的 DEMO。多点连线 DemoDemo 访问地址: https://kongfandong.cn/demo/d3-multipoint-connection/index.htmlPS 端支持拖拽更改点位置，移动端暂不支持LineType：切换不同的 D3 内置的连线类型Add Random Point: 你可以添加更多的点进行连线各个点可以拖拽更改当前位置部分连线算法可以修改系数参数(bundle、cardinal、catmullRom)利用 D3js 的这个连线算法，实现了一个简单的曲线自动校正的 Canvas 画板，参考下面的 Demo曲线自动校正 DemoDemo 访问地址: https://kongfandong.cn/demo/d3-adjust-line/index.htmlCanvas 简易画板设置的 AdjustAngel 配置偏移角度通过 AdjustAngel 进行点的取样，然后使用 D3js 的连线算法进行重连总结实现平滑的曲线，可以通过 D3js 内置的几种曲线算法生成一个插值曲线，该曲线原则上是贝塞尔曲线，所以可以在 SVG 和 Canvas 中都可以应用上。若要研究各种曲线算法的原理请参考官方源码。官方文档：https://d3js.org.cn/document/d3-shape/#curves"},{"title":"使用Taro-next将个人网盘功能扩展到微信小程序","url":"/article/使用Taro-next将个人网盘功能扩展到微信小程序","content":"使用Taro-next将个人网盘功能扩展到微信小程序 - 前言笔者之前实现了一个 PC 端的个人网盘功能，包含断点续传、文件秒传的文件管理系统，具体请参考文章**《断点续传与个人网盘系统的前后端设计》**于是构思想将个人网盘功能扩展到小程序，沿用之前的后端（接口基本不需要改动），只需要完成移动端的 UI 实现即可。又由于 PC 端是基于 Vue 实现的，为了方便开发所以想直接采用跨平台框架，将 vue 代码转成小程序，而且这样还可以考虑后续转出 H5 或原生手机客户端等。基于功能的原因，该小程序原则上不可能通过审核，所以只会作为个人练手项目。跨平台框架选型关于跨平台框架的选型，对比了当前主要用的 3 个框架mpvue: 美团开源的使用 Vue.js 开发小程序的前端框架，但当前好像好久没人维护了uniapp: uni-app 是一个使用 Vue.js 开发小程序、H5、App 的统一前端框架Taro-next: 京东开源的多端开发框架，2.X 版本是需使用 React 的，当前 beta3.X 版本对 vue 加入了支持。对比了下，最终还是觉得选用 Taro-next 进行开发，虽然当前还是 beta 版，但是文档已经完善了，基本不影响使用。安装与启动Taro 安装参考官方文档，先全局安装 Taro 脚手架，再初始化一个项目，安装依赖。使用npm run dev:weapp启动开发环境，然后使用微信开发者工具导入项目即可进行预览（最好申请一个小程序 Id，以便后续可以真机预览等功能）。引入 Vant-weapp UI 框架可以直接下载 vant-weapp 的生成包，直接放在目录下。然后就可以在页面的配置下引入自定义组件，Taro 会自动将这些同步到打包后的文件夹。微信小程序打包的时候也会自动去除没用到的包。// index.config.jsexport default {  usingComponents: {    \"van-icon\": \"../../components/vant/icon/index\",    \"van-action-sheet\": \"../../components/vant/action-sheet/index\",    \"van-notify\": \"../../components/vant/notify/index\",    \"van-dialog\": \"../../components/vant/dialog/index\",    \"van-field\": \"../../components/vant/field/index\",    \"van-checkbox\": \"../../components/vant/checkbox/index\",    \"van-checkbox-group\": \"../../components/vant/checkbox-group/index\",    \"van-progress\": \"../../components/vant/progress/index\",    \"van-toast\": \"../../components/vant/toast/index\",  },};具体请参考:Taro-使用小程序原生第三方组件和插件Vant-weapp 官方文档另外，一些 Vant 的全局组件可以挂载到 Vue 的实例上，方便使用。// app.jsimport Vue from \"vue\";// ...import Notify from \"./components/vant/notify/notify\";import Dialog from \"./components/vant/dialog/dialog\";import Toast from \"./components/vant/toast/toast\";// ...Vue.prototype.$notify = Notify;Vue.prototype.$dialog = Dialog;Vue.prototype.$toast = Toast;// ...const App = new Vue({  store,  onShow(options) {},  render(h) {    return h(\"block\", this.$slots.default);  },});export default App;使用时需注意，vant 该 3 个组件是要先定义默认节点的，要在一个全局的 vue 中加入以下节点代码然后就可以在 vue 中使用// Notifythis.$notify({ type: \"danger\", message: e || \"登录失败\", duration: 1000 });// Dialogthis.$dialog  .confirm({    message:      \"此操作会将文件移动到回收站，你可在一个月内进行恢复操作，一个月后将永久删除\",  })  .then(() => {    // do something  })  .catch(() => {    // on cancel  });// Toastthis.$toast.loading({  mask: true,  message: \"上传中...\",});请求封装可以为请求加入请求拦截与响应拦截，基于Taro.request封装一些请求头，如content-type: application/json提取baseURL，将请求前缀提取出来配置，方便修改请求拦截器：将 sessionId 注入到请求头响应拦截器：只给 errCode 为 200 的请求通过，其余请求为错误请求，直接使用 Notify 组件自动弹出错误信息参考代码如下：// fetch.jsimport Taro from \"@tarojs/taro\";import Notify from \"../components/vant/notify/notify\";const interceptor = function (chain) {  const requestParams = chain.requestParams;  const sessionId = Taro.getStorageSync(\"sessionId\");  if (sessionId) requestParams.header.sessionId = sessionId;  return chain.proceed(requestParams).then(    (res) => {      const data = res.data;      if (data.errCode === 200) {        return Promise.resolve(data.data);      } else {        Notify({          type: \"danger\",          selector: \"#van-notify\",          message: data.errMsg,          duration: 1000,        });        return Promise.reject(data.errMsg);      }    },    (err) => {      Notify({        type: \"danger\",        selector: \"#van-notify\",        message: \"服务端异常\",        duration: 1000,      });      return err.toString();    }  );};Taro.addInterceptor(interceptor);export const baseURL = \"http://localhost:5001/storage\";export const instance = (method, url, data, options) => {  return Taro.request({    dataType: \"json\",    header: {      \"content-type\": \"application/json\",    },    method,    url: baseURL + url,    data,    ...options,  });};将封装的实例像全局组件那样挂载到 Vue 的实例上，方便使用。// app.jsimport Vue from \"vue\";// ...import { instance, baseURL } from \"./utils/fetch\";// ...Vue.prototype.$get = (url, data, options) =>  instance(\"get\", url, data, options);Vue.prototype.$post = (url, data, options) =>  instance(\"post\", url, data, options);Vue.prototype.$baseURL = baseURL;// ...const App = new Vue({  store,  onShow(options) {},  render(h) {    return h(\"block\", this.$slots.default);  },});export default App;然后就在 vue 中使用:// getthis.$get(\"/getFileList\", {  currentPath: this.currentPathParams,}).then((data) => {  this.fileList = data;});//postthis.$post(\"/delete\", {  deleteList,}).then((data) => {  this.$notify({ type: \"success\", message: \"操作成功\", duration: 1000 });  this.$emit(\"onNeedRefresh\");});关于文件上传微信的文件上传并不能拿到文件实例，查了好多资料，并无找到能够进行文件分片的功能，所有不能实现断点续传了。这次直接使用了简单的单文件上传，后端添加了一个 simpleUpload 接口接收，其余操作在这就不细说了。微信并无提供直接调用系统文件管理器的 API（可能也没权限），这次采用了微信提供的以下几种方式取代wx.chooseImage: 从本地相册选择图片或使用相机拍照wx.chooseVideo: 拍摄视频或从手机相册中选视频wx.chooseMessageFile: 从客户端会话选择文件这几个接口都会返回一个含有选取路径的成功回调，能拿到文件路径进行上传    上传逻辑handleUploadFile (type = 1) {  const callback = (res) => {    this.$emit('update:actionVisible', false)    this.$toast.loading({      mask: true,      message: '上传中...'    })    const filePaths = type === 3 ? res.tempFiles.map(item => item.path) : res.tempFilePaths    Promise.all(      filePaths.map(item => {        return Taro.uploadFile({          url: this.$baseURL + '/simpleUpload',          filePath: item,          name: 'file',          formData: {            targetPath: this.currentPathArr.join('/')          },          header: {            sessionid: Taro.getStorageSync('sessionId')          }        }).then(data => {          try {            const res = JSON.parse(data.data)            if (res.errCode === 200) {              const { fileName } = res.data              this.$notify({ type: 'success', message: `上传成功，文件保存为${fileName}`, duration: 2000 })              this.$emit('onNeedRefresh')            } else {              this.$notify({ type: 'success', message: `上传失败，${res.errMsg}`, duration: 2000 })            }          } catch (e) {            this.$notify({ type: 'success', message: `上传失败，服务端错误`, duration: 2000 })          }        })      })    ).then(() => {      this.$toast.clear()    })  }  if (type === 1) {    wx.chooseImage({      count: 1,      sizeType: ['original', 'compressed'],      sourceType: ['album', 'camera'],      success (res) {        callback(res)      }    })  } else if (type === 2) {    wx.chooseVideo({      sourceType: ['album', 'camera'],      maxDuration: 60,      camera: 'back',      success (res) {        callback(res)      }    })  } else if (type === 3) {    wx.chooseMessageFile({      count: 1,      success (res) {        callback(res)      }    })  }}文件预览由于微信小程序文件存储最大为 10M，所以基本不可能实现下载功能了。于是把下载功能改成了在线预览功能，当前支持以下几种文件类型办公文档（doc、docx、xls、xlsx、ppt、pptx、pdf）：这几种文档都可以通过Taro.openDocumentAPI 实现预览操作图片（jpg、png、svg、gif）：拿到图片临时地址后，使用浮层和image组件显示视频（mp4、mov、m4v、3gp、avi、m3u8）：直接将视频地址放到浮层的video组件中显示以上，除了视频外，其余都是要先通过wx.downloadFile将文件下载到本地生成临时路径再执行相应预览操作，这时候可以添加下载进度条优化用户体验。而视频不会直接进行下载，需要后端将视频资源设为流视频（Accept-Range），这样视频可以一边下载一边播放。进度条使用微信原生请求事件onProgressUpdate实现主要代码handleActionPreview (el) {  const target = this.actionFileInfo  const targetPath = this.currentPathArr.join('/') + '/' + target.fileName  const realPath = targetPath.replace('$Root', this.$baseURL)  const sessionId = Taro.getStorageSync('sessionId')  if (videoSuffixArr.includes(target.suffix)) {    // 视频直接展示    this.handleActionCancel()    this.mediaPreviewVisible = 2    this.videoPreviewURL = realPath + '?sessionid=' + Taro.getStorageSync('sessionId')  } else if (this.previewArr.includes(target.suffix)) {    // 其他类型先下载    this.downloadTask = wx.downloadFile({      url: realPath,      header: {        'sessionid': sessionId      },      success: (data) => {        const { tempFilePath } = data        if (imgSuffixArr.includes(target.suffix)) {          this.mediaPreviewVisible = 1          this.imgPreviewURL = tempFilePath        } else if (documentSuffixArr.includes(target.suffix)) {          Taro.openDocument({            filePath: tempFilePath          })        }        this.handleActionCancel()      },      fail: () => {        this.$notify({ type: 'danger', message: `下载失败`, duration: 2000 })      }    })    this.downloadTask.onProgressUpdate((res) => {      this.isDownloading = true      const { progress, totalBytesWritten, totalBytesExpectedToWrite } = res      this.downloadingInfo = { progress, totalBytesWritten, totalBytesExpectedToWrite }    })  }}PS：后端是 Koa 服务，使用了koa-range为静态资源下的视频实现分段请求功能，视频就可以一边下载一边播放，在 chrome 中视频可以进行拖动进度条，若不使用这个，在 chrome 中视频是无法拖动进度条的。其余功能批量操作使用了 van-checkgroup 实现，直接更换当前文件列表，但尽量保持节点位置没发生改变，可防止界面回流影响性能。移动文件该功能对应 PC 端上的移动，可以选择文件仅移动或者是复制，PC 端是使用一个树形组件进行选择文件夹。但发现 Vant 等并没有相关树形组件，可能需要自己封装一个，然后直接采用了用户点击移动操作后，记录选择的文件信息，然后用户需要进入到相应目录下进行粘贴操作。关于打包发布执行命令npm run build:weapp后，其余操作与正常小程序一样。"},{"title":"Vue3上手, 使用vite实现一个简单的Todolist应用","url":"/article/Vue3上手, 使用vite实现一个简单的Todolist应用","content":"Vue3上手, 使用vite实现一个简单的Todolist应用 - Git 仓库: https://github.com/leon-kfd/TodoListVitePratice在线 Demo: https://kongfandong.cn/todoViteVite is an opinionated web dev build tool that serves your code via native ES Module imports during dev and bundles it with Rollup for production.目前，Vue-cli 还未能直接搭建 vue3 应用，需要在 vue2 的项目上通过执行vue add next命令进行升级。而 Vite 是官方提供的一个可以快速搭建 vue3 新工具，它是一个简易的 http 服务器，无需通过 webpack 打包即可实时解析 vue3 文件，并能实现热更新。现在最新版的 vite 已经提供了一个简易模板，可以直接使用一下命令快速搭建安装与启动$ npx create-vite-app $ cd $ npm install$ npm run dev具体参考官方仓库: https://github.com/vuejs/vite#getting-startedTypescriptvite 最新版默认已经可以直接对 typescript 进行解析编译，直接在 vue 文件中的script标签下加入lang=\"ts\"即可。Sass执行命令安装 sass， npm i sass -D， 然后在 vue 文件的style标签下加入lang=\"scss\"即可，这些与以前 vue2 都是一样的。Vuex支持 vue3 的 vuex 最新版现在还未正式发版，需要使用npm i vuex@next -D来安装。Vuex 的新语法进行了一些变更，你需要使用 Vuex.createStore 来创建，其他语法没有区别。import Vuex from \"vuex\";// or => import { createStore } from 'vuex'export default Vuex.createStore({  state: {},  mutations: {},  actions: {},  modules: {},});然后在 main.js 引入这个文件并 useimport { createApp } from \"vue\";import App from \"./App.vue\";import store from \"./store/index.js\";import \"./assets/base.css\";createApp(App).use(store).mount(\"#app\");Vue Compostion ApiVue3 最大的一个变化就是使用Vue Compostion Api， 现在官方已经提供了 中文文档本次只用到了其中很少一部分的 API，而且可能使用方式不一定准确，仅供参考，望见谅。功能设计对 TodoList 的操作：完成、取消、添加、删除可记录不同日期的 TodoList对记录了 TodoList 的日期进行标注现在先来看一下最终项目 DEMO 成果点击头部的日期会弹出日期选择，可选择其他日期。实现主要组件Card.vue组件，然后里面包含一个日期选择组件DatePicker.vue为了练习一下 vuex 在 vue3 的使用，将当前的选择日期记录在了 vuex 中。主要逻辑代码// Card.vueimport { ref, reactive, computed, watch } from \"vue\";import { useStore } from \"vuex\";import { Todo, getTodoList, setTodoList } from \"../model/todo\";import DatePicker from \"./DatePicker.vue\";const weekArr: string[] = [  \"Sunday\",  \"Monday\",  \"Tuesday\",  \"Wednesday\",  \"Thursday\",  \"Firday\",  \"Saturday\",];export default {  name: \"Card\",  components: {    DatePicker,  },  directives: {    focus(el) {      el.focus();    },  },  props: {    date: String,    showAddBtn: Boolean,  },  setup(props) {    const store = useStore();    const state = {      editingValue: ref(\"\"),      showDatePicker: ref(false),    };    let todoList = reactive([]);    watch(      () => props.date,      (val) => {        todoList.length = 0;        todoList.push(...getTodoList(props.date));        // state.showDatePicker.value = false      },      {        immediate: true,      }    );    const weekDay = computed(() => weekArr[new Date(props.date).getDay()]);    const formatterDate = computed((): string => {      const arr: string[] = new Date(props.date).toDateString().split(\" \");      return `${arr[1]} ${arr[2]}, ${arr[3]}`;    });    const handleChecked = (item: Todo): void => {      item.isChecked = !item.isChecked;      setTodoList(props.date, todoList);      store.commit(\"refreshTodoListDateArr\");    };    const handleRemove = (index: number): void => {      todoList.splice(index, 1);      setTodoList(props.date, todoList);      store.commit(\"refreshTodoListDateArr\");    };    const handleAdd = (): void => {      state.editingValue.value = \"\";      todoList.push({        content: \"\",        isChecked: false,        isEditing: true,      });    };    const handleEditSubmit = (item: Todo, index: number): void => {      if (item.isEditing) {        if (state.editingValue.value) {          item.content = state.editingValue.value;          item.isEditing = false;        } else {          todoList.splice(index, 1);        }        setTodoList(props.date, todoList);        store.commit(\"refreshTodoListDateArr\");      }    };    return {      weekDay,      formatterDate,      todoList,      handleChecked,      handleRemove,      handleAdd,      handleEditSubmit,      ...state,    };  },};组件功能实现都比较简单，本次只为了熟悉语法，所以具体代码逻辑在这就不进行讲解了。项目打包使用npm run build或者npx vite build即可打包项目。Vite 的打包基于 Rollup需要注意的是，vite 也是想 vue-cli 那样提供了配置文件的，在根目录下添加vite.config.js即可，例如本地打包后项目是通过 https://kongfandong.cn/todo 来访问的，如果使用默认的打包配置，会出现资源 404 的问题。这时需要给打包配置资源路径/todo，加入以下配置：// vite.config.jsmodule.exports = {  base: \"/todo\",};Vite 还提供了很多其他的配置，具体请参考: https://github.com/vuejs/vite/blob/master/src/node/config.ts一个插曲一开始，我使用 vuex 是使用getCurrentInstance获取 vue 的实例想像 vue2 那样类似this.$store.state来使用 vuex 的，就像下面的代码import { computed, getCurrentInstance } from \"vue\";export default {  setup() {    const { ctx } = getCuurentInstance();    const selectedDate = computed(() => ctx.$store.state.selectedDate);    return {      selectedDate,    };  },};这样 ts 会报错，提示 ctx 的类型没找到，通过查源码发现 vue 并没有把 ctx 的类型抛出。然后我就改成了import { computed, getCurrentInstance } from \"vue\";export default {  setup() {    const instance: any = getCuurentInstance();    const ctx = instance.ctx;    const selectedDate = computed(() => ctx.$store.state.selectedDate);    return {      selectedDate,    };  },};然后一切如愿进行，开发环境下什么问题也没有了。但是，到了打包之后运行，浏览器就报错了index.js:9 Uncaught TypeError: Cannot read property 'state' of undefined    at index.js:9    at n (index.js:1)    at Object.get value [as value] (index.js:1)    at Object.get (index.js:1)    at Object.get (index.js:1)    at index.js:9    at Vn (index.js:1)    at Proxy. (index.js:9)    at Proxy. (index.js:1)    at nt (index.js:1)(anonymous) @ index.js:9...报错 state 没找到，程序上的 vuex 的$store 是 undefined。然后我查了好久也没找到解决办法，于是只能在 github 上提个 issue。最后得到了解答，原来在setup()中是不能使用getCurrentInstance的!具体 Issue: https://github.com/vuejs/vite/issues/156最终的解决办法，引入 vuex 的 useStore 方法，就可以在 setup 中使用 vuex 了。最后代码改为:import { computed } from \"vue\";import { useStore } from \"vuex\";export default {  setup() {    const store = useStore();    const selectedDate = computed(() => ctx.$store.state.selectedDate);    return {      selectedDate,    };  },};总结这个小 Demo 的实现过来还是遇到了不少问题，但还是一一解决了，可以让我对 vue3 与 typescript 进行了初步的了解。目前只是因为还不太熟悉，但感觉 vue3 未来发展潜力还是很大的。还有 Vite 这个工具好像也是很强大的，目测 Vue3 官方后面有可能会直接推荐使用该工具进行开发了，有可能会放弃的 Webpack 了。"},{"title":"断点续传与个人网盘系统的前后端设计","url":"/article/断点续传与个人网盘系统的前后端设计","content":"断点续传与个人网盘系统的前后端设计 - 功能设计登录鉴权：进入系统必须先登录，未登录无法访问到后端接口与网盘的静态资源上传：断点续传、文件秒传文件分享：生成一个随机密钥字符串与一个资源访问地址，输入密钥验证成功即可访问到该资源，密钥会在一定时间内过期回收站：删除后的文件默认先保留在回收站，7 天后自动删除文件操作: 新建文件夹、重命名、移动、删除、批量删除技术选型前端：使用 Vue 构建，使用 ElementUI 构建 UI，使用 vue-simple-uploader 插件实现上传的断点续传、文件秒传功能。后端：使用 Koa 实现，直接使用 Koa 搭建静态资源服务器（即个人网盘资源目录），加入静态资源鉴权，使用原生 Nodejs 处理文件管理与上传功能。问题与思考Q：是否需要使用数据库，将文件信息保存到数据库中？原则上，文件的增删查改都将使用原生 nodejs 进行操作，这些都不需要使用到数据库。但是原生 nodejs 并不能直接读取到文件的 MD5 值，在断点续传与秒传功能中就无法通过传来的 MD5 标识跟本地的文件进行匹配。所以还是需要建立一个含文件 MD5、文件路径等信息的数据表记录本地文件的 MD5。Q：若使用了数据库记录文件 MD5 信息，怎么保证数据表的数据与本地物理存储是同步的？如果进行文件操作并不是通过该文件管理系统，而是直接在 windows 上进入到网盘目录进行文件增删改，这时我们的应用是无法监听到文件的变更的，数据表数据并不会更新。这样就会出现我把某个文件删除了，但是数据表仍然记录了该文件是已经上传的情况。原本是想采用使用定时器定时对本地文件与数据表进行数据同步，但是发现这样在后期文件多或嵌套深的情况下性能会很差，这种方式并不合适。由于这些信息只是在文件断点续传与秒传功能中需要用到，后面采用的方案为：直接在预探请求中先判断数据库信息是否与本地物理存储相符，如果不相符则认为本地已不存在，需要重新上传。（原则上是不推荐直接使用 windows 进入目录进行文件操作，而是都通过这个文件管理系统进行文件操作）Q: 同一个文件，但存在于网盘不同目录下，同时在不同目录删除该文件，回收站中是否会冲突？删除文件时，使用原文件名+时间(yyyy-MM-dd HH:mm)进行重命名后再移动文件到回收站。同时需要往数据库记录文件删除的信息，删除前的文件路径与删除时间等，以便实现文件还原与回收站定时清理的功能。Q：文件夹并无 MD5 值，删除文件夹如何确保可以还原？删除文件夹与删除文件属于同样的操作，也是通过文件夹名+时间重命名后移动到回收站目录。但是数据库中需要使用一个新的数据表记录文件夹的删除信息。实现文件鉴权登录时保留 session, 然后使用一个中间件鉴权，如果没有 session 则不允许访问系统除登录接口外的其他任何请求，包括静态资源。使用 koa-static 构建静态资源服务器，并将 defer 属性设置为 true，让它允许通过鉴权中间件。// ...app.use(async (ctx, next) => {  if (ctx.url.includes(\"/storage\") && ctx.url !== \"/storage/login\") {    if (!ctx.session.isLogin) {      ctx.body = r.loginError();      return;    }  }  await next();});// ...app.use(  static(__dirname + \"/public\", {    defer: true,  }));// ...const router = new Router({  prefix: \"/storage\",});// ...router.post(\"/login\", async (ctx) => {  const { access } = ctx.request.body;  if (!access) {    ctx.body = r.parameterError();    return;  }  try {    const base64Decode = new Buffer.from(access, \"base64\");    const genAccess = base64Decode.toString();    if (storageRootKey !== genAccess) {      ctx.body = r.error(311, \"密码错误\");      return;    }    ctx.session.isLogin = true;    logger(\"登入Storage\");    ctx.body = r.success();  } catch (e) {    ctx.body = r.error(310, \"登录失败\");  }});这里设置的文件系统接口为 storage/*，静态资源服务器为 public/storage，登录时前后端会把密码进行简单 base64 转码。若未登录直接访问静态资源，则回返回错误信息。未登录直接访问登录后在访问断点续传与文件秒传文件 md5 计算实现断点续传与文件秒传的前提是需要确定出文件的唯一标识，最好的方式是计算出文件的 md5 值。由于选择的 vue-simple-uploader 没有直接提供文件 md5 计算的 api，因此需要手动实现。这里采用 spark-md5 插件计算文件的 md5，在 file-added 事件中，直接用 fileReader 读取文件，根据每个切片循环算出 md5。注意尽量不要直接一次读取整个文件的 md5，直接读取大文件在 IE 浏览器中有可能会出现卡死的情况，遍历读取每个切片可以减轻浏览器计算压力。methods: {  hanldeFileAdd (file) {    const fileList = this.$refs.uploader.files    const index = fileList.findIndex(item => item.name === file.name)    if (~index) {      file.removeFile(file)    } else {      file.targetPath = this.currentPath      this.computeMD5(file)    }  },  computeMD5 (file) {    const fileReader = new FileReader()    const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice    let currentChunk = 0    const chunkSize = CHUNK_SIZE    const chunks = Math.ceil(file.size / chunkSize)    const spark = new SparkMD5.ArrayBuffer()    this.$nextTick(() => {      this.createMD5Element(file)    })    loadNext()    fileReader.onload = e => {      spark.append(e.target.result)      if (currentChunk  {          this.setMD5ElementText(file, `校验MD5 ${((currentChunk / chunks) * 100).toFixed(0)}%`)          document.querySelector(`.uploader-list .file-${file.id} .uploader-file-actions`).style.display = 'none'        })      } else {        const md5 = spark.end()        file.uniqueIdentifier = md5        file.resume()        this.destoryMD5Element(file)        document.querySelector(`.uploader-list .file-${file.id} .uploader-file-actions`).style.display = 'block'      }    }    fileReader.onerror = function () {      this.$nextTick(() => {        this.setMD5ElementText(file, '校验MD5失败')      })      file.cancel()    }    function loadNext () {      const start = currentChunk * chunkSize      const end = ((start + chunkSize) >= file.size) ? file.size : start + chunkSize      fileReader.readAsArrayBuffer(blobSlice.call(file.file, start, end))    }  },  createMD5Element (file) {    this.$nextTick(() => {      const el = document.querySelector(`.uploader-list .file-${file.id} .uploader-file-status`)      const MD5Status = document.createElement('div')      MD5Status.setAttribute('class', 'md5-status')      el.appendChild(MD5Status)    })  },  destoryMD5Element (file) {    this.$nextTick(() => {      const el = document.querySelector(`.uploader-list .file-${file.id} .uploader-file-status .md5-status`)      if (el) {        el.parentNode.removeChild(el)      }    })  },  setMD5ElementText (file, text) {    const el = document.querySelector(`.uploader-list .file-${file.id} .uploader-file-status .md5-status`)    if (el) {      el.innerText = text    }  }}将计算完的 MD5 直接替换到 file 对象的 uniqueIdentifier 属性上，最终发送的请求中的 identifier 将是文件的 MD5，后端通过该字段进行识别。Vue-simple-uploader 文件列表状态需要加入计算 MD5 相关状态，可以通过 css 为原文件列表增加多一层 md5 状态层，然后通过相关事件进行显隐。断点续传默认 Vue-simple-uploader 提供了文件上传时的暂停/开始操作，你可以在上传过程中随时暂停。但是这个并不是真正的断点续传，因为页面刷新后，上传状态并没有保存下来，仍会重新从第一片重新上传。若将状态保留到 localstorage 中，仍是不太现实的，最好的方式是由后端返回是否需要当前这个切片，因为后端能知道当前该文件已上传的切片。testChunks 属性设为 true（默认）时，每个切片会先发送一个不含文件流的预探 get 请求给后端，通过后端返回的 http 状态码（可更改）判断该切片是否需要发送。默认每个切片都会发送一个预探请求，这样假如一个 10 个切片的文件就会产生 20 个请求，造成浪费。最理想的情况是预探请求只发送一个。新版 simple-uplder 也考虑到这点，并提供了 checkChunkUploadedByResponse 属性，可以将预探请求设置为一个，后端为这个预探请求直接返回当前已经有的切片数组，然后前端直接判断切片请求是否需要发送。例：文件上传到一半，点了暂停，然后刷新网页，再重新上传。文件校验完 Md5 后，预探请求返回已存在的切片数组[1~25]，然后真正切片请求会直接从第 26 片开始上传。前端处理// 前端vue-simple-uploader配置项options: {  target: (instance, chunk, isTest) => isTest ? '/api/storage/testUpload' : '/api/storage/upload',  query: () => {    return {      targetPath: this.currentPath    }  },  chunkSize: CHUNK_SIZE,  allowDuplicateUploads: false,  checkChunkUploadedByResponse: (chunk, message) => {    const response = JSON.parse(message)    const existChunk = response.data.map(item => ~~item)    return existChunk.includes(chunk.offset + 1)  }}其中/storage/testUpload 为预探请求（get），storage/upload 为真正切片上传请求（post）。checkChunkUploadedByResponse 控制只上传后端不存在的切片。后端处理router.get(\"/testUpload\", async (ctx) => {  const { identifier, filename, targetPath = \"$Root\", totalChunks } = ctx.query;  const chunkFolderURL = `${storageChunkPath}/${identifier}`;  try {    const checkExistResult = await query(      `select * from storage where id = ? and isComplete = 1 and isDel = 0`,      identifier    );    // 检查是否已经完整上传过该文件    if (checkExistResult.length > 0) {      let { fullPath } = checkExistResult[0];      let realPath = fullPath.replace(\"$Root\", storageRootPath);      // 检查当前DB信息是否与物理存储相符      if (fs.existsSync(realPath)) {        // 检查目标位置是否与之前上传的位置一样，不一致则复制过去        let targetFilePath = `${targetPath}/${filename}`;        if (fullPath !== targetFilePath) {          targetFilePath = targetFilePath.replace(\"$Root\", storageRootPath);          fs.copyFileSync(realPath, targetFilePath);        }        // 返回全部分片数组        const chunksArr = Array.from(          { length: totalChunks },          (item, index) => index + 1        );        ctx.body = r.successData(chunksArr);        return;      }    }    if (!fs.existsSync(chunkFolderURL)) {      fs.mkdirSync(chunkFolderURL, { recursive: true });      const now = DateFormat(new Date(), \"yyyy-MM-dd HH:mm:ss\");      const sql = `replace into storage(id, fullPath, updatedTime, isComplete, isDel) values(?, ?, ?, 0, 0)`;      await query(sql, [identifier, `${targetPath}/${filename}`, now]);      ctx.body = r.successData([]);    } else {      const ls = fs.readdirSync(chunkFolderURL);      ctx.body = r.successData(ls);    }  } catch (e) {    ctx.status = 501;    ctx.body = r.error(306, e);  }});router.post(\"/upload\", async (ctx) => {  const {    chunkNumber,    identifier,    filename,    totalChunks,    targetPath = \"$Root\",  } = ctx.request.body;  const { file } = ctx.request.files;  const chunkFolderURL = `./public/storage-chunk/${identifier}`;  const chunkFileURL = `${chunkFolderURL}/${chunkNumber}`;  if (chunkNumber !== totalChunks) {    const reader = fs.createReadStream(file.path);    const upStream = fs.createWriteStream(chunkFileURL);    reader.pipe(upStream);    ctx.body = r.success();  } else {    const targetFile = `${targetPath}/${filename}`.replace(      \"$Root\",      storageRootPath    );    fs.writeFileSync(targetFile, \"\");    try {      for (let i = 1; i  ${e}`);      fs.unlinkSync(targetFile);    }  }});在 testUpload 请求中，通过数据库与本地切片生成已存在的切片数组给前端，若从未传过还需要更新数据库记录。在 upload 请求中，对每个切片使用 nodejs 管道流进行读写，将文件保留在 chunk 文件夹中，并以 md5 值为文件名，存放目标文件的切片。当遇到最后一个切片时，执行合并文件操作（需要注意，最后一个切片由于流未关闭，这个时刻最后一个切片文件是还没保存到本地，只是可以直接读取临时文件）。合并文件完成后，删除切片文件夹，并更新数据库信息，记录该文件已经完成。当上传一个本地已经存在的文件时，由于数据库记录了该 md5 文件是已经完成的，所以预探请求会返回全部切片数组，前端就不会再发送 upload 请求从而实现了文件秒传。即使上传的目标目录与本地已存在文件处在不同目录，在预探请求时识别到时，也会进行复制操作，前端也不需要再传。断点续传演示上传过程暂停，然后刷新页面，重新上传同一个文件，可以发现文件是从上传暂停的地方重新开始。文件秒传演示上传上面演示的同一个文件，由于发现是已经存在的文件，则会直接返回成功。至此，一个断点续传、秒传功能的前后端都实现完了。另外该系统还有一些对文件进行移动、删除、下载的功能都是比较简单的，基本都是使用 nodejs 的 fs 模块就能实现，这里就不细说了。该系统前端 Git: https://github.com/leon-kfd/FileSystem由于目前该后端是嵌入到了本人的其他系统里面，还未能开源，等有空会整理出一份。同时系统部分功能由于时间问题也还没有空去完善，望见谅。"},{"title":"个人组件库展示站点搭建总结","url":"/article/个人组件库展示站点搭建总结","content":"个人组件库展示站点搭建总结 - 在线预览个人组件库: Howdy目录Markdown-loader将 Vue 文件转为 Markdown路由生成优化关于部署Markdown-loader使用 Markdown-loader 可以将 markdown 文件转为 Html 代码，直接在vue.config.js中加入 webpack 相关配置。并且使用 Highlight.js 对 Markdown 中出现的代码块进行高亮展示。Markdown-loader 中可直接配置 Highlightjs。const hljs = require(\"highlight.js\");module.exports = {  configureWebpack: (config) => {    config.module.rules.push({      test: /\\.md$/,      use: [        {          loader: \"html-loader\",        },        {          loader: \"markdown-loader\",          options: {            highlight: (code) => {              if (                code[0] === \" hljs.highlightAuto(code).value,            pedantic: false,            gfm: true,            tables: true,            breaks: false,            sanitize: false,            smartLists: true,            smartypants: false,            xhtml: false,          },        },      ],    });    // ... //  },};这里本来是用了 highlightAuto 自动识别代码语言的，但是发现效果不太理想，所有直接通过判断里面出现关键内容应用不同代码语言。然后就可以直接通过 import 将 markdown 文件引入到代码中。例如下面 import 引入了 README.md 文件，readme 就是解析后的 HTML 代码，最后直接传给封装好的组件用 v-html 渲染出来即可。          import ReadmeFrame from \"@/components/ReadmeFrame\";  import readme from \"@/howdy/packages/standard-table/README.md\";  export default {    name: \"readme\",    components: {      ReadmeFrame,    },    data() {      return {        readme,      };    },  };然后为渲染后的页面设定主题 CSS，可以直接在网上找现成 CSS 代码，例如可 Markdown 编辑器 Typora 的主题。将 Vue 文件转为 Markdown编写一个 nodejs 脚本，将相关目标组件 Example 的 Vue 文件转成 Markdown，然后通过上面 Markdown-loader 即可实现代码高亮展示。// vue-to-md.jsconst fs = require(\"fs\");const glob = require(\"glob\");const classifys = fs.readdirSync(\"src/pages\");classifys.map((classify) => {  fs.mkdirSync(`src/code/${classify}`, { recursive: true });});glob(\"src/pages/**/example/example*.vue\", (err, files) => {  if (err) {    throw err;  }  files.map((file) => {    const codeFileName = file      .replace(\"pages\", \"code\")      .replace(\"example/\", \"\")      .replace(\"vue\", \"md\");    const code = fs.readFileSync(file, \"utf8\");    const output = `\\`\\`\\`vue\\n${code}\\n\\`\\`\\``;    fs.writeFileSync(codeFileName, output);  });});glob 可以使用 “ * ” 通配符匹配所需文件在package.json文件的 vue 启动与打包命令前加入运行该脚本的命令// package.json\"scripts\": {  \"serve\": \"npm run vue-to-md && vue-cli-service serve\",  \"build\": \"npm run vue-to-md && vue-cli-service build\",  \"lint\": \"npm run vue-to-md && vue-cli-service lint\",  \"vue-to-md\": \"node src/utils/vue-to-md.js\"}通过路由匹配等逻辑，将生成的 example.md 文件引入到相关页面中。async loadCode () {  try {    let code = await import(`@/code/${this.mainName}/${this.page.replace(this.mainName + '-', '')}.md`)    this.code = code.default  } catch (e) {    console.log(e)  }}路由生成优化目前组件库中含有多个组件与指令，一个组件或指令又会含有若干个 Example，最终需要定义很多个路由（一个 Example 对于一个路由）。由于它们之间是存在很多相似的引用逻辑的，所以可以将它们抽离出来形成函数，从而不用每次手动去定义一个新的路由，只要更改传入的参数即可。// router.jsimport Vue from \"vue\";import VueRouter from \"vue-router\";Vue.use(VueRouter);const packageList = [  {    name: \"resize-directive\",    exampleNum: 5,  },  {    name: \"scroll-directive\",    exampleNum: 5,  },  {    name: \"mouse-menu-directive\",    exampleNum: 6,  },  {    name: \"size-observer-directive\",    exampleNum: 2,  },  {    name: \"animation-dialog\",    exampleNum: 3,  },  {    name: \"standard-table\",    exampleNum: 9,  },  {    name: \"img-zoom-directive\",    exampleNum: 3,  },];const packageRouter = packageList.map((item) => {  const { name, exampleNum } = item;  return {    name,    routers: [      {        path: `/${name}/readme`,        name: `${name}-readme`,        component: () => import(`@/pages/${name}/example/readme`),      },      ...Array.from({ length: exampleNum }, (item, index) => {        return {          path: `/${name}/example${index + 1}`,          name: `${name}-example${index + 1}`,          component: () =>            import(`@/pages/${name}/example/example${index + 1}`),        };      }),    ],  };});const routes = [  {    path: \"/\",    name: \"home\",    component: () => import(\"@/views/home\"),  },  ...Object.keys(packageRouter).map((key) => {    const { name, routers } = packageRouter[key];    return {      path: `/${name}`,      name,      component: () => import(`@/pages/${name}`),      children: routers,      redirect: `/${name}/readme`,    };  }),];const router = new VueRouter({  mode: \"history\",  base: process.env.BASE_URL,  routes,});export default router;这样下次要添加新的组件或者添加新的 Example 只需要更改packageList即可。这种方式前提是需要确保包文件目录是符合规范的。其实还有一种更好的办法，就是编写一个 nodejs 脚本，读取文件目录自动生成路由文件，这样就能完全不需要手动配置任何路由，这种方法类似Nuxtjs的路由自动生成。关于部署由于最终的访问地址为 https://kongfandong.cn/howdy ，所以需要配置 publicPath 为 howdy，不然会出现资源 404路由使用了History模式，所以服务器端需要加入相关配置。该组件库展示站点最终是放在了Koa2的静态资源里面（因为 Example 里面涉及了一些 Mock 接口数据，为了方便把它们合在了同一个后端服务里面）。Koa2 中可以使用 koa2-connect-history-api-fallback 中间件实现 History 路由模式。// ...const static = require(\"koa-static\");const { historyApiFallback } = require(\"koa2-connect-history-api-fallback\");app.use(  historyApiFallback({    htmlAcceptHeaders: [\"text/html\", \"application/xhtml+xml\"],    rewrites: [      {        from: \"/howdy\",        to: \"/howdy\",      },    ],  }));// 打包后的文件放在public目录下,使用koa-static放出静态资源服务app.use(static(__dirname + \"/public\"));// ...若是使用 nginx 搭建的静态资源服务器，可以参考官方推荐的 Nginx 配置 实现 History 模式。在线预览个人组件库: Howdy"},{"title":"Github Webhooks与Koa2实现简单的前端自动化部署","url":"/article/Github Webhooks与Koa2实现简单的前端自动化部署","content":"Github Webhooks与Koa2实现简单的前端自动化部署 - 前言因为博客使用 Gatsbyjs 进行搭建，Markdown 文章写完之后会打包成静态 HTML 文件，文章是存在项目文件中并非数据库中，所以每次进行博客文章更新后，都需要重新进行打包构建。在进行 git push 后，我需要连到云服务器中，然后进入项目目录，执行 git pull / npm run clean / npm run build 等命令。为了简化该操作，通过使用 Github 的 Webhooks 服务，在服务端监听 git push 事件，然后自动执行编写好的脚本从而实现自动化构建部署。以后 Git push 后就无需再进行后续操作，由脚本完成。目前主流的自动化构建部署工具可以选择 Jenkins，Jenkins 是一个持续集成管理平台，提供超过 1000 个插件来支持构建、部署、自动化， 满足任何项目的需要。但由于 Jenkins 是基于Java环境，而且功能过于强大，对于个人的项目来说有点大材小用，而且加重个人服务器资源的压力。所以没有采用 Jenkins 进行自动化构建部署，而是采用自己编写的Koa2服务来接收 Github Webhook 来实现简单自动化构建。配置 Webhooks进入自己需要监听 Push 请求的 Github 仓库，点击 Settings => Webhooks => Add webhook填写自己服务器请求地址，配置 Secret(用于后面的 Sha1 解码验证)，并选择要监听的事件，本次只监听 push进入到对应 Webhooks 详情，下方可以查看到每个请求记录，点击 Redeliver 可以重新发送该请求。后端 Koa2 服务后端的 Koa2 服务是本功能的最重要的环节。其处理流程：接收 Github Webhooks 的 Post 请求提取请求头与请求 Body 信息，并验证是否缺少必要参数使用 Crypto 的 HMACSHA1 算法，将服务端设置的密钥对请求 Body 进行哈希编码，然后判断解码出来的与请求头中的 x-hub-signature 是否匹配，防止有他人对自己的服务器发送了伪造的非法请求或篡改了 Github 原请求。针对不同 Git 事件与 Git 仓库使用 Nodejs 的 child_process 执行不同的脚本文件const Router = require(\"koa-router\");const Response = require(\"../utils/response\");const crypto = require(\"crypto\");const { exec } = require(\"child_process\");const logger = require(\"../utils/log\");const { webhookSecret } = require(\"../config/config\");const r = new Response();const router = new Router();// router的路由路径在Github配置webhook时配置，webhook为向该路径发送请求router.post(\"/****\", async (ctx) => {  const requestData = ctx.request.body;  const sig = ctx.headers[\"x-hub-signature\"];  const event = ctx.headers[\"x-github-event\"];  const id = ctx.headers[\"x-github-delivery\"];  if (!sig || !event || !id) {    ctx.body = r.error(310, \"No Github hook headers\");    return;  }  if (![\"ping\", \"push\"].includes(event)) {    ctx.body = r.error(311, \"Gihub Hook events not allow\");    return;  }  const { repository, sender } = requestData;  if (!repository || !sender) {    ctx.body = r.error(312, \"Missing essential parameters\");    return;  }  const { name: repositoryName } = repository;  logger(\"接收到Webhook\", 1, `event:${event}, respository: ${repositoryName}`);  const clientSig = `sha1=${crypto    .createHmac(\"sha1\", webhookSecret)    .update(JSON.stringify(requestData))    .digest(\"hex\")}`;  if (sig !== clientSig) {    logger(\"Webhook X-Hub-Signature解码\", 0, \"解码不匹配\");    ctx.body = r.error(313, \"X-Hub-Signature does not match\");    return;  }  if (event === \"ping\") {    ctx.body = {      errCode: 200,      errMsg: \"Success\",    };  } else if (event === \"push\") {    ctx.body = {      errCode: 200,      errMsg: \"Success\",    };    if (repositoryName === \"****\") {      updateBlog();    }  }});// updateBlog为接收到hook后要执行的操作const updateBlog = () => {  exec(\"****.bat\", (err) => {    if (err) {      logger(\"执行****.bat\", 0, err);      return;    }    logger(\"执行****.bat\", 1);  });};module.exports = {  githubWebhookRouter: router,};在新建 Webhooks 后，github 会发送一个 ping 事件到目标服务器，所以这里加多了一种 ping 事件的处理（直接返回 200）。本次我设置了只有 push 事件会发请求，所以只处理了 push 事件，如果设置 Webhooks 监听其他事件，例如 release、issues、star 等，可自行扩展对应功能。其他说明后端可直接使用原生 Nodejs 搭建服务，使用 github-webhook-hanlder 包可快速搭建建议设置 Secert 密钥，防止伪造的请求本方式适合简单的前端资源自动化部署构建，对于大型的项目还是建议使用 Jenkins 等持续集成工具进行自动化部署可监听 Github Webhooks 其他事件，issue、start 等，并通过 Github API 可实现下 Git 仓库机器人等功能Github Webhooks 请求中有很多有用的信息，例如多人项目中你可以记录是由谁 push 的，或者处理的是哪个分支等，都可以提取出来进行不同的处理。脚本可使用 Shell 编写再由 Nodejs 的 child_process 去执行，也可以直接编写 nodejs 命令直接去执行文件操作。社区也提供很多类似shelljs、exec-sh等 NPM 包可以更优雅的编写脚本命令。这种方式适合将网站自动部署到自己的个人服务器，如果没有服务器可以采用Github Page方式部署，这时候可以利用Github Action去实现，具体后面再写一篇文章说明。以上内容未经授权请勿随意转载。"},{"title":"浏览器导航首页设计","url":"/article/浏览器导航首页设计","content":"浏览器导航首页设计 - 2021/11/01 更新: 以下内容为旧版网站的记录，站点地址已更新为 Howdz 起始页项目地址一个浏览器首页站点, 包含可切换的常用搜索引擎搜索功能, 键盘布局添加快捷收藏网站, 并加入键盘按键监听可快速打开, 自定义背景图, 配置同步功能等功能系统半成品已部署与线上，在线访问：https://howdz.xyz目录搜索引擎切换功能键盘收藏夹功能背景图切换功能配置同步功能关于优化搜索引擎切换功能该功能时为了便于让用户可快速切换不同的搜索引擎，可以涉及不同领域的搜索，例如常用引擎、视频、翻译等搜索。在搜索框聚焦状态下按 Tab 键就可按用户规定的顺序快速切换引擎（Shift + Tab 向上切换）。handleInputKeyDown (e) {  if (e.keyCode === 9) {    if (e.shiftKey) {      this.activeEngine = this.activeEngine = this.$store.state.engineList.length - 1 ? 0 : ++this.activeEngine      e.preventDefault()    }  }  if (e.keyCode === 13) {    window.open(this.$store.state.engineList[this.activeEngine].link + encodeURIComponent(this.searchKey))  }}寻找目前主流搜索引擎关键字拼接规则记录列表和寻找 Icon 保存到 VUEX 中，目前设置了默认引擎为 Bing 国内、国外、百度，然后备用设置了 Google、搜狗、Bilibili、淘宝等。用户可以在设置页通过拖拽切换引擎顺序与添加备用搜索到当前。拖拽功能使用 vuedragable 实现，将当前引擎与备用引擎设为同一个 group，即可让两者可以互相拖拽，并且通过 pull 设置实现当 engineList 长度为 1 是不可再向外拖出。...当前引擎组 1 }\"  @end=\"handleDragEnd\">                  {{item.name}}      备用引擎组                  {{item.name}}      ...键盘收藏夹功能用户可通过点击模拟键盘按键快速跳转到收藏好的网站，未设置时点击则弹窗让用户添加。主要功能实现：截取用户输入的 http 地址中的域名，然后通过“域名 + /favicon.ico”获取主流网站的 Icon，当获取不到时，使用截取 Title 的首字符作为 Icon。亦可使用谷歌的 Favicon 服务，通过“http://www.google.cn/s2/favicons?domain= + 域名”获取网站 Icon，但获取出来的都是固定 16px x 16px 大小。使用 Flex 布局实现模拟键盘布局监听按键添加事件，window.open 打开用户收藏的网站使用个人组件Animation Dialog实现动画弹窗(Where open where close 交互){{userSettingKeyMap[key].remark.slice(0,1)}}背景图切换功能背景图使用的图片来自免费无版权图片壁纸网站Unplash，并使用其提供的API 服务获取 JSON 图片列表。其 Api 接口不可直接调用，需要注册获取到 accessKey 之后将其放在请求中才可使用接口服务，且普通用户每小时只可调用 50 次，因此不合适直接把获取 unsplash 图片的请求放在前端。后端实现后端使用 Nodejs 每天定时调用 1 次获取 Unsplash 最新图片的接口，并把返回数据保留为 json 文件，然后由 Nodejs 提供接口，即背景图片以天为单位更新。// Nodejs后端服务const { unsplashApiKey } = require('../config/config') // 调用UnsplashAPI的Access Keyconst schedule = require('node-schedule') // nodejs定时器服务...// 获取Unsplash最新图片const getUnsplashPhotos = async () => {  const pageSize = 30  const photosList = []  try {    for (let page = 1; page  {        return item.width > item.height      }).map(item => {        const { id, width, height, color, description, urls, links } = item        return { id, width, height, color, description, urls, links }      })      photosList.push(...result)    }    const today = getToday()    const info = {      date: today,      num: photosList.length,      list: photosList    }    const data = JSON.stringify(info, null, '\\t')    fs.writeFileSync(`./unsplash/${today}.json`, data)    logger('定时获取Unsplash图片')  } catch (e) {    logger('定时获取Unsplash图片', 0, e)  }}...// 获取今日图片router.get('/photos', async ctx => {  const fileList = fs.readdirSync('./unsplash').sort((a, b) => {    const [date1] = a.split('.')    const [date2] = b.split('.')    return new Date(date2) - new Date(date1)  })  const latest = fileList[0]  const txt = fs.readFileSync(`./unsplash/${latest}`, 'utf-8')  try {    const data = JSON.parse(txt)    ctx.body = r.successData(data)  } catch (e) {    ctx.body = r.error(308, e)  }})...// 每天1点定时获取Unsplash图片保存JSONconst runUnsplashSchedule = () => {  schedule.scheduleJob('0 1 1 * * *', () => {    getUnsplashPhotos()  })}runUnsplashSchedule()...前端处理前端使用 Vuex 保留用户每次切换获取的图片缓存，在不刷新页面下，同一张图片不需要再次加载。并将最后一次获取到的图片转成 Base64 保存到 Localstorage 里面的，此时要注意多数浏览器 Localstorage 最大存储 5M，需要做下判断，图片过大就不进行缓存了。关于获取图片资源，一开始是使用 new Image()方案然后监听 onload 事件用 canvas 将 Img 转成 Base64 来实现。但是后面发现 canvas 将 Unsplash 图片转成 base64 会有跨域问题，尽管将Img 的 crossOrigin 属性设成’anonymous’，在 Chrome 下没问题，但是用 Safari 依然报跨域。最后采用了另外一种方案，使用 Ajax 去加载图片资源。需要将 responseType 改为 arraybuffer 方式，然后读取二进制拼接成 base64。使用 Ajax 方式还有一个优点，就是可以获取到加载进度，直接用 img 的 src 去获取无法监听图片下载进度。ajax 获取图片为 base64// ajax读取图片为base64// processFn为监听进度的回调export const getBase64ByAjax = (url, formatter = \"image/png\", processFn) => {  return new Promise((resolve, reject) => {    const xhr = new XMLHttpRequest();    xhr.open(\"GET\", url, true);    xhr.responseType = \"arraybuffer\";    xhr.onload = (e) => {      if (xhr.status === 200) {        const uInt8Array = new Uint8Array(xhr.response);        let i = uInt8Array.length;        const binaryString = new Array(i);        while (i--) {          binaryString[i] = String.fromCharCode(uInt8Array[i]);        }        const data = binaryString.join(\"\");        const base64 = window.btoa(data);        const dataURL =          \"data:\" + (formatter || \"image/png\") + \";base64,\" + base64;        resolve(dataURL);      }    };    xhr.onerror = (e) => {      reject(e);    };    xhr.onprogress = (e) => {      processFn && processFn(e);    };    xhr.send();  });};Vuex 记录图片加载及其缓存export default new Vuex.Store({  state: {    // ... //    unsplashImgList: [],    downloadingImgInfo: null,    downloadingImgBase64: \"\",    downloadingProcess: 0,    cacheImg: {},    // ... //  },  mutations: {    // ... //    setEngineList(state, engineList) {      state.engineList = engineList;    },    setBackupEngineList(state, backupEngineList) {      state.backupEngineList = backupEngineList;    },    setUnsplashImgList(state, unsplashImgList) {      state.unsplashImgList = unsplashImgList;    },    setDownloadingImgInfo(state, downloadingImgInfo) {      state.downloadingImgInfo = downloadingImgInfo;    },    setDownloadingProcess(state, downloadingProcess) {      state.downloadingProcess = downloadingProcess;    },    setDownloadingImgBase64(state, base64) {      document.body.style.setProperty(        \"--textColor\",        base64 ? \"#f8f8f9\" : \"#262626\"      );      document.body.style.setProperty(        \"--textShadowColor\",        base64 ? \"#262626\" : \"transparent\"      );      state.downloadingImgBase64 = base64;      const userTodayImgCache = {        date: getToday(),        base64,      };      const toJson = JSON.stringify(userTodayImgCache);      if (toJson.length = 1440) {          imgURL = downloadingImg.urls.regular            .replace(\"w=1080\", \"w=1920\")            .replace(\"q=80\", \"q=70\");        } else {          imgURL = downloadingImg.urls.regular.replace(\"q=80\", \"q=70\");        }        commit(\"setDownloadingImgInfo\", downloadingImg);        commit(\"setDownloadingProcess\", 0);        const processFn = (e) => {          const process = ~~((e.loaded / e.total) * 100);          commit(\"setDownloadingProcess\", process);        };        getBase64ByAjax(imgURL, \"image/png\", processFn).then((data) => {          const dataURL = data;          commit(\"setDownloadingImgBase64\", dataURL);          commit(\"setCacheImg\", { imgId, base64: dataURL });          commit(\"setDownloadingImgInfo\", null);        });      }    },    // ... //  },});当前并未实现自定义图片上传功能，后续进行优化配置同步功能该功能未在线上版本实现，但已有实现思路。方案一：用户注册账号，登录后自动同步配置。该方案为传统方案，但是系统功能单一，用上账户功能对用户来说是过于麻烦，而且涉及到账号安全问题。（不推荐）方案二：用户点击保存配置按钮后生成一串 AccessKey 随机字符串，在另一端设备用户输入该字符串发送请求，后端返回改字符串对应的配置信息。随机字符串生成后有效期为 24 小时，后端定时删除。（推荐）方案三：导出 json 文件进行同步。（不推荐）关于优化打包优化项目使用到的 vue、vuex 等资源使用线上 CDN 服务，可减少打包大小并减轻服务端带宽压力。使用 Vue-cli3 的项目在 vue.config.js 中加入 externals 配置，不打包 vue 相关资源，并在 index.html 加入 Vue CDN 资源。// vue.config.jsmodule.exports = {  // ...  configureWebpack: (config) => {    config.externals = {      vue: \"Vue\",      vuex: \"Vuex\",      // 'vue-router': 'VueRouter',      // axios: 'axios'    };  },  // ...};因系统功能完全是单页面完成，删除了 vue-router 功能，涉及请求不多也将 axios 改为原生 ajax 实现图片优化由于 Unsplash 为境外站点，国内访问有可能速度很慢。可以考虑在 nodejs 进行获取图片请求后，再将每张图片保存到本地。或者为了减轻服务器带宽压力，可以将图片上传到七牛云或腾讯云的提供的图片资源服务。Unsplash 提供的图片 api 接口，可以判断当前用户的设备，例如区分手机端和 PC 端，然后更改请求部分参数使其返回不同大小的图片。将图片缓存到浏览器中。系统半成品已部署与线上，在线访问：https://howdz.xyz以上内容未经授权请勿随意转载。"},{"title":"CSS实现判断鼠标进入方向","url":"/article/CSS实现判断鼠标进入方向","content":"CSS实现判断鼠标进入方向 - 使用纯 CSS 判断鼠标进入方向执行不一样的方向动画，或搭配 JS 实现同时记录进入方向与移出方向目录纯 CSS 实现Clip-pathTransformJS 实现Demo 展示判断方向算法移入方向判断移出方向判断总结纯 CSS 实现实现纯 CSS 判断鼠标进入方向，主要是先通过将 DIV 以对角线切割为 4 个部分，然后即可为这 4 个部分写入 选择器执行不同方向的动画。如果 DIV 是正方形的话，对角线切割就很简单，可以用伪元素通过 rotate(45deg)就可以实现。但是当 Div 是长方形的时候，就需要使用以下的方法了。目前可以通过 2 种 CSS3 的方式实现使用 CSS3 的 clip-path 属性定向裁剪区域使用 CSS3 的 transfrom 属性，将 div 倾斜再旋转一定角度实现，需要同时用到 rotate 和 skew2 种 2D 变换。Clip-pathDemoclip-path 方式实现主要代码逻辑CSS.box {  width: 400px;  height: 300px;  background: #eee;  position: relative;  overflow: hidden;  border: 2px solid #262626;}.top,.right,.bottom,.left {  position: absolute;  width: 100%;  height: 100%;  top: 0;  left: 0;  transition: all 0.4s;}.top:after,.right:after,.bottom:after,.left:after {  position: absolute;  content: \"\";  width: 100%;  height: 100%;}.top {  top: -100%;  background: rgb(255, 228, 177);}.right {  right: -100%;  left: auto;  background: rgb(200, 177, 255);}.bottom {  bottom: -100%;  top: auto;  background: rgb(177, 255, 225);}.left {  left: -100%;  background: rgb(177, 189, 255);}.top:after {  clip-path: polygon(0 0, 50% 50%, 100% 0);  top: 100%;  left: 0;}.right:after {  clip-path: polygon(100% 0, 50% 50%, 100% 100%);  right: 100%;  top: 0;}.bottom:after {  clip-path: polygon(0 100%, 50% 50%, 100% 100%);  bottom: 100%;  left: 0;}.left:after {  clip-path: polygon(0 0, 50% 50%, 0 100%);  left: 100%;  top: 0;}.top:hover {  top: 0;}.right:hover {  right: 0;}.bottom:hover {  bottom: 0;}.left:hover {  left: 0;}/* 解决层级阻断问题 */.top:hover ~ .right,.top:hover ~ .bottom,.top:hover ~ .left,.right:hover ~ .bottom,.right:hover ~ .left,.bottom:hover ~ .left {  display: none;}HTML  Hover Here  From Top  From Right  From Bottom  From Left为.top 的 Div 创建一个伪元素，然后使用 clip-path: polygon(0 0, 50% 50%, 100% 0) 定位左上角、中心、右上角切割出上部分的三角形，这时.top 实际区域是一个五边形（.top 时其伪元素也会包含在其中）。TransformDemotransform 实现方式与 clip-path 方式基本差不多，主要是先将伪类通过旋转加偏移变换成一个平行四边形，将变换顶点定位在中心，然后隐藏超出部分即可。transform 方式实现主要代码逻辑 (仅列举与 clip-path 不一样的代码)body {  --angle: 37deg;}/*...省略部分...*/.top:after,.right:after,.bottom:after,.left:after {  position: absolute;  content: \"\";  width: 100%;  height: 100%;  transform-origin: 0 0;}.top:after {  top: 150%;  left: 50%;  transform: rotate(calc(var(--angle) - 180deg)) skew(      calc((var(--angle) - 45deg) * 2)    );}.right:after {  top: 50%;  left: -50%;  transform: rotate(calc(0deg - var(--angle))) skew(      calc((45deg - var(--angle)) * 2)    );}.bottom:after {  top: -50%;  left: 50%;  transform: rotate(var(--angle)) skew(calc((var(--angle) - 45deg) * 2));}.left:after {  top: 50%;  left: 150%;  transform: rotate(calc(180deg - var(--angle))) skew(      calc((45deg - var(--angle)) * 2)    );}/*...省略部分...*/transform 方式最大缺点就是需要计算角度，先将变换顶点改为 0 0（原为 50% 50%），就可以直接套用以上的变换公式，再使用 acrtan(高/宽)计算出角度，然后赋值给—angle 自定义 CSS 变量即可。PS: calc 计算函数中值为 0 时也要带上单位，不然无法生效JS 实现Demo 展示判断方向算法以上的 Demo 中，为每个 DIV 加入了 mouseenter 和 mouseleave 的事件监听，通过判断方向后然后为其添加不同方向的移入动画和移出动画。JS 实现判断进入方向，依然是将 div 按对角线切割成 4 个三角形，然后通过判断鼠标事件中移入的点是否在三角形内来确定方向。这里涉及到了一个如何判断点在区域内的算法实现。以下提供一个函数判断点 P 和点 O 是否在直线 AB 的同一侧/* 判断两点是否位于直线同一侧 * @param {Object} p - P点坐标 * @param {Object} o - O点坐标 * @param {Object} a - A点坐标(直线AB) * @param {Object} b - B点坐标(直线AB) * @return {Boolean} */function isSameSide(p, o, a, b) {  return (    ((p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x)) *      ((o.x - a.x) * (b.y - a.y) - (o.y - a.y) * (b.x - a.x)) >=    0  );}该函数需要传入 4 个点坐标（含有 x,y 属性的对象），参数 1 和参数 2 是需要判断的两点，参数 3 和参数 4 是确定直线的两点。使用的是矢量法，过程无需用到三角函数，而且参数 1 和参数 2 顺序可互换，参数 3 和参数 4 顺序也可互换。判断点在三角形内，就需要用 3 次这个函数分别为三条边进行判断。移入方向判断如图，点 P 为鼠标事件移入获取到的点，当点 P 与点 O 在直线 AB 同一侧、点 P 与点 A 在直线 OB 同一侧、点 P 与点 B 在直线 AO 同一侧，即可判断出点 P 在三角形 AOB 内，即鼠标从上方进入。转换为代码即可写成:...if (isSameSide(p,o,a,b) && isSameSide(p,a,o,b) && isSameSide(p,b,a,o)) {  console.log('Slide From Top')}...移出方向判断同理，要判断移出方向，可以判断点 P 与点 O 不在直线 AB 同一侧、点 P 与点 A 是否在直线 OB 同一侧、点 P 与点 B 是否在直线 AO 同一侧，即可判断出鼠标从上方移出。转换为代码即可写成:...if (!isSameSide(p,o,a,b) && isSameSide(p,a,o,b) && isSameSide(p,b,a,o)) {  console.log('Slide Out Top')}...下面提供 Demo 实现的主要 JS 代码，由于 CSS 需要定义几个简单的 Slide 动画，代码比较简单，由于篇幅有限就不在本文列出，感兴趣的可以直接查看 Demo 源码。var isSameSide = function (p, o, a, b) {  return (    ((p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x)) *      ((o.x - a.x) * (b.y - a.y) - (o.y - a.y) * (b.x - a.x)) >=    0  );};var boxList = Array.prototype.slice.call(document.querySelectorAll(\".box\"));var mouseenterEvent = function (e) {  var el = e.currentTarget;  var { top, left, width, height } = el.getBoundingClientRect();  var a = { x: left, y: top };  var b = { x: left + width, y: top };  var c = { x: left + width, y: top + height };  var d = { x: left, y: top + height };  var o = { x: left + width / 2, y: top + height / 2 };  var p = { x: e.x, y: e.y };  if (    isSameSide(p, o, a, b) &&    isSameSide(p, a, o, b) &&    isSameSide(p, b, o, a)  ) {    el.setAttribute(\"class\", \"box slide-from-top\");  } else if (    isSameSide(p, o, b, c) &&    isSameSide(p, b, o, c) &&    isSameSide(p, c, b, o)  ) {    el.setAttribute(\"class\", \"box slide-from-right\");  } else if (    isSameSide(p, o, c, d) &&    isSameSide(p, c, o, d) &&    isSameSide(p, d, o, c)  ) {    el.setAttribute(\"class\", \"box slide-from-bottom\");  } else if (    isSameSide(p, o, a, d) &&    isSameSide(p, a, o, d) &&    isSameSide(p, d, o, a)  ) {    el.setAttribute(\"class\", \"box slide-from-left\");  } else {    el.setAttribute(\"class\", \"box slide-from-top\");  }};var mouseleaveEvent = function (e) {  var el = e.currentTarget;  var { top, left, width, height } = el.getBoundingClientRect();  var a = { x: left, y: top };  var b = { x: left + width, y: top };  var c = { x: left + width, y: top + height };  var d = { x: left, y: top + height };  var o = { x: left + width / 2, y: top + height / 2 };  var p = { x: e.x, y: e.y };  if (    !isSameSide(p, o, a, b) &&    isSameSide(p, a, o, b) &&    isSameSide(p, b, o, a)  ) {    el.setAttribute(\"class\", \"box slide-out-top\");  } else if (    !isSameSide(p, o, b, c) &&    isSameSide(p, b, o, c) &&    isSameSide(p, c, b, o)  ) {    el.setAttribute(\"class\", \"box slide-out-right\");  } else if (    !isSameSide(p, o, c, d) &&    isSameSide(p, c, o, d) &&    isSameSide(p, d, o, c)  ) {    el.setAttribute(\"class\", \"box slide-out-bottom\");  } else if (    !isSameSide(p, o, a, d) &&    isSameSide(p, a, o, d) &&    isSameSide(p, d, o, a)  ) {    el.setAttribute(\"class\", \"box slide-out-left\");  } else {    el.setAttribute(\"class\", \"box slide-out-top\");  }};for (var i = 0; i < boxList.length; i++) {  boxList[i].addEventListener(\"mouseenter\", mouseenterEvent);  boxList[i].addEventListener(\"mouseleave\", mouseleaveEvent);}总结使用纯 CSS 实现判断方向会有一个比较大的缺点，就是浏览器鼠标移动事件含有一定延迟，当鼠标速度很快的进入 div 时，有可能 会延迟执行到后面的元素。同时纯 CSS 方式只可判断移入方向，还未能实现可以同时判断移入和移出。需要在记录移入方向的同时，再记录移出方向目前想到的只可使用 JS 去辅助实现了。使用 JS 实现最主要是要运用到判断两点位于直线同侧的算法，这个算法只涉及四则运算，也比较简洁。获取 DIV 四个顶点和中心的坐标可以用getBoundingClientRect()来获取元素的 top,left,width,height 计算出来。以上内容未经授权请勿随意转载。2021/10/01 更新, 找到了一个使用 Grid 布局实现的移入方向 Demo: CSS-only direction-aware hover effect"},{"title":"简易电商系统开发记录(Nuxtjs+Koa)","url":"/article/简易电商系统开发记录(Nuxtjs+Koa)","content":"简易电商系统开发记录(Nuxtjs+Koa) - 使用 Nuxtjs + Koa + Mysql 实现的极简风格电商系统，此为个人大学课余期间(2018)的练手项目，部分功能未完全实现。DEMO 系统在线预览地址: http://eidea.kongfandong.cn系统功能✅ 登录注销✅ 首页商品轮播✅ 首页商品推荐✅ 商品分类搜索✅ 商品详情✅ 购物车增删改✅ 商品收藏✅ 生成订单❌ 个人资料/地址管理❌ 商品规格模块❌ 支付模块Nuxtjs 相关axios 封装封装 axios，加入拦截器，统一处理接口返回的错误请求，只有code为 200 才为正确请求，其余统一弹窗错误message。Nuxtjs 一个特性就是服务端渲染，同时可以先由服务端请求到异步初始数据后再直出页面，使用asyncData方法。若要在 asyncData 里面使用封装后添加了拦截器的 axios，则需要将 axios 实例注入到 nuxt 上下文中。这里采用了同时注入的方法将 Axios 注入 Vue 实例与 context 上下文中。// axios.jsimport axios from \"axios\";const baseURL = \"/api/\";const onRequest = (config) => config;const onResponse = (response) => {  if (response.data.code == 200) {    return response;  } else {    return Promise.reject(      (response.data && response.data.message) || \"未知错误\"    );  }};const onRequestError = (err) => Promise.reject(err);const onResponseError = (err) => Promise.reject(err);const instance = axios.create({  baseURL,  headers: {    \"Content-Type\": \"application/json\",  },});instance.interceptors.request.use(  (config) => onRequest(config),  (err) => onRequestError(err));instance.interceptors.response.use(  (response) => onResponse(response),  (err) => onResponseError(err));const get = (url, params) => instance.get(url, { params });const post = (url, data) => instance.post(url, data);export { get, post };export default ({ app, store }, inject) => {  const nuxtAxios = app.$axios;  nuxtAxios.setHeader(\"Content-Type\", \"application/json\");  nuxtAxios.onRequest((config) => onRequest(config));  nuxtAxios.onRequestError((err) => onRequestError(err));  nuxtAxios.onResponse((response) => onResponse(response));  nuxtAxios.onResponseError((err) => onResponseError(err));  inject(\"get\", (url, params) => nuxtAxios.$get(baseURL + url, { params }));  inject(\"post\", (url, data) => nuxtAxios.$post(baseURL + url, data));  inject(\"baseURL\", baseURL);};其余插件font-awesome CSS 图标库vue-lazyload 图片懒加载加入购物车动画使用定位 + transition + transform + 贝塞尔曲线模拟抛物线动画效果将过渡动画 left 设为线性，top 设为为 cubic-bezier(0.56, 0.15, 0.43, 0.85)时，在执行过渡时就能模拟出元素一个抛物线运动，曲线函数可以在 Chrome 控制台试出来// 主要代码showAnimateAddCart () {  const imgEl = document.getElementById('goodsImg')  const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = imgEl  const newImgEl = new Image()  newImgEl.src = this.goodsimg  newImgEl.style.cssText = `    position:fixed;    width: ${offsetWidth}px;    height: ${offsetHeight}px;    left: ${offsetLeft}px;    top: ${offsetTop}px;    opacity: 1;    transform: rotate(0)`  document.body.appendChild(newImgEl)  const cartEl = document.getElementById('ShoppingCartBtn')  const { offsetTop: cartTop, offsetLeft: cartLeft } = cartEl.parentNode  newImgEl.style.cssText = `    position:fixed;    width: 0;    height: 0;    left: ${cartLeft}px;    top: ${cartTop}px;    opacity: 0;    transform: rotate(360deg);    transition: width 1s,    height 1s,    left 1s,    top 1s cubic-bezier(0.56, 0.15, 0.43, 0.85),    opacity 1s ease-out,    transform 1s ease-out`  setTimeout(() => {    document.body.removeChild(newImgEl)  }, 2000)}关于 Nuxtjs 部署因为网站有动态数据，所有无法使用 npm run generate 的方式生成静态资源来部署。只能通过 npm run build，然后 npm run start 启动一个服务来跑。这是还是要保留开发环境用的 proxy 环境，使用反向代理方式代理所有后端接口。// nuxt.config.jsproxy: {  '/api/': {    target: 'http://localhost:3001',    pathRewrite: {      '^/api/': ''    }  }}后端 Koa 相关后端只用作一个普通的接口服务器，涉及的技术不多，只用到了几个基本的 koa 插件koa-routerkoa-sessionkoa-statickoa-bodyparsermysql备注SQL 语句尽量都采用escaping query values，使用?占位符代替变量，可以防止 SQL 注入攻击SQL 查询分页，查询总数时可以采用子查询方法，虽然性能差别不大，但是代码看上去可以较简洁// 搜索商品router.get(\"/query\", async (ctx) => {  const {    sex,    classify,    page = 1,    pageSize = 12,    minPrice = 0,    maxPrice = 99999,    order = \"default\",    word,  } = ctx.query;  let sql = `select * from goods where goodsprice between ? and ? `;  let paramsArr = [minPrice, maxPrice];  if (sex) {    sql += `and sex = ? `;    paramsArr.push(sex);  }  if (classify) {    sql += `and classify = ? `;    paramsArr.push(classify);  }  if (word) {    sql += `and goodsname like ? or goodsdetail like ? `;    paramsArr.push(`%${word}%`, `%${word}%`);  }  const totalSql = `select count(*) as total from (${sql}) as temp `;  const totalResult = await query(totalSql, paramsArr);  if (!totalResult) {    ctx.body = r.error();    return;  }  if (order) {    if (order === \"low\") {      sql += `order by goodsprice `;    } else if (order === \"high\") {      sql += `order by goodsprice desc `;    }  }  sql += `limit ?, ? `;  paramsArr.push((page - 1) * pageSize, pageSize);  const result = await query(sql, paramsArr);  if (!result) {    ctx.body = r.error;    return;  }  ctx.body = r.successPage(result, page, pageSize, totalResult[0].total);});网站截图首页搜索页购物车订单个人中心PS: 该项目仅作学习交流所用，不可作商业用途，所有图片来源于网上以上内容未经授权请勿随意转载。DEMO 系统在线预览地址: http://eidea.kongfandong.cn"},{"title":"考试系统设计总结","url":"/article/考试系统设计总结","content":"考试系统设计总结 - 该系统成品已部署与线上，在线访问：ExamSystem系统线上环境部分功能已锁定学生端登录测试账号 1: user1 密码: 7gzt9i0lkh测试账号 2: user2 密码: lyufmklxy教师端登录测试账号: admin1 密码: qrmeke4p75该系统为本人毕业设计，由于时间仓促，部分功能设计不太优雅，请见谅。以下截取于部分论文相关内容。目录系统架构技术选型Axios 拦截器Laravel 相关前端界面截图系统架构系统功能架构系统分为学生系统与教师系统，教师用户在登录页登录后自动跳转到教师系统首页，然后教师可以进行创建考试，创建的过程中可以对考试进行临时保存。把题目与考试班级等考试信息填写完毕后可以进行发布考试。这时学生用户登录到学生系统后，学生主页将会显示自己需要进行的考试列表或自己已经完成的考试列表。学生点击进入考试则可进行考试，在规定时间内完成考试后进行交卷。提交试卷后，将会弹出自动阅卷结果，学生可以进入查看自己的答卷与分数。与此同时，教师系统可获取到学生完成考试的列表，教师可以查看学生的成绩与答卷，并对需要进行阅卷的考试进行阅卷。教师系统提供一个公共功能，教师可以发布、编辑、删除公告，发布的公告将展示在学生系统上。系统技术架构技术选型本研究中，总体采用前后端分离的技术进行开发。前端使用近年流行的 MVVM 框架 Vue，同时使用其附属的 Vue-router 路由管理模块和 Vuex 状态管理模块。UI 将采用 Element-ui 框架，系统将采用部分响应式布局设计。前端使用 axios 工具，其基于 Ajax 技术开发，前端可通过它把所有需要的动态数据以 JSON 格式请求后端，同时获取后端返回到的 JSON 数据。再将动态数据经过逻辑处理渲染到页面中。后端总体采用 PHP 技术开发，使用 PHP 的 MVC 框架 Laravel，其具有路由、中间件、查询构造器等功能。本次后端仅作为 API 服务器，并不会直接使用后端的 View 视图层。数据库方面采用 Mysql 数据库，基于其能与 PHP 语言友好结合，运行速度快，提供事务处理功能的特点。同时，关系型数据库，能方便的处理在线考试系统模型关联问题。Axios 拦截器配置 Axios 拦截器，可以在请求之前和请求之后作统一处理。每一个后端请求都需要默认传送一个 token 作为身份认证。所以前端在请求前，可以统一配置这个 token，默认为每个请求自动拼上 token 字段。后端每个请求都会返回错误码与请求信息，前端 Axios 可以对每个响应进行统一处理。例如，字段码为 200 则说明请求成功，其他字段码均为错误请求，可以为错误请求统一弹出错误信息。同时本次用拦截器加入了一个取消重复请求与切换路由自动取消之前路由未完成请求的功能。axios.jsconst baseURL = process.env.NODE_ENV === \"production\" ? \"./api\" : \"./api/api\";// 创建实例const instance = axios.create({  baseURL,  timeout: 90000,  headers: {    \"Content-Type\": \"application/json\",  },});let axiosPendingList = []; // 记录请求// 请求拦截instance.interceptors.request.use((config) => {  let mark = config.url;  let markIndex = axiosPendingList.findIndex((item) => item.name == mark);  if (markIndex > -1) {    axiosPendingList[markIndex].cancel(\"重复请求\");    axiosPendingList.splice(markIndex, 1);  }  const CancelToken = axios.CancelToken;  const source = CancelToken.source();  config.cancelToken = source.token;  config._mark = mark;  axiosPendingList.push({    name: mark,    cancel: source.cancel,  });  let token = sessionStorage.getItem(\"token\") || \"\";  if (token) {    if (config.data) {      config.data.token = token;    } else {      config.data = {};      config.data.token = token;    }  }  if (    config.method === \"post\" &&    config.headers[\"Content-Type\"] !== \"application/json\"  ) {    config.data = qs.stringify(config.data);  }  return config;});// 响应拦截instance.interceptors.response.use(  (response) => {    let markIndex = axiosPendingList.findIndex(      (item) => item.name == response.config._mark    );    if (markIndex > -1) {      axiosPendingList.splice(markIndex, 1);    }    let data = response.data;    if (data.code === 200) {      return data.data;    } else {      if (data.code === 300) {        Message({          showClose: true,          message: data.message,          type: \"error\",          duration: 2000,        });        router.push(\"/login\");      } else if (data.message) {        Message({          showClose: true,          message: data.message,          type: \"error\",          duration: 2000,        });      }      return Promise.reject(response);    }  },  (err) => {    if (!err.message === \"重复请求\") {      Message({        showClose: true,        message: \"Api访问失败，请检查网络..\",        type: \"error\",        duration: 1500,      });      return Promise.reject(err);    }  });export { baseURL, axiosPendingList };export default instance;router.js...// 路由守卫拦截，切换路由取消未完成请求router.beforeEach((to, from, next) => {  axiosPendingList.map(item => {    if (!item.notAllowCancel) {      item.cancel()    }  })  next()})...Laravel 相关中间件本项目采用前后端分离方式开发，以 Token 形式保存当前的用户信息。Token 可分为学生 Token 和教师 Token，每一个请求都会带有 Token 以识别当前的用户。所以我们可以设置一些请求中间件，在每次请求前统一对 Token 进行处理。CheckToken.php...class CheckToken{  /**  * Handle an incoming request.  *  * @param  \\Illuminate\\Http\\Request  $request  * @param  \\Closure  $next  * @return mixed  */  public function handle($request, Closure $next)  {    $token = $request -> input('token');    $now = date('Y-m-d H:i:s');    $token_row = Token::where([['token', '=', $token],['overdue_after', '>', $now]]);    if ($token_row->exists()) {      // 更新Token过期时间      $update_overdue = date('Y-m-d H:i:s', strtotime(\"+2 hour\"));      $token_row->update(['overdue_after' => $update_overdue]);      return $next($request);    } else {      return response(Response::loginError());    }  }}...查询构造器使用 Laravel 提供的查询构造器功能，能够方便的让我们的 SQL 语句变得简单，查询数据库数据更加快速。它使用 PDO 连接方式连接数据库，并且通过封装可以有效的防止 SQL 注入攻击。查询构造器语法什么简洁，并且采用拼接的方式组成。例如：table(‘user’)->get()，它将别转换为 select * from user 的 SQL 命令。在可以运行原生 SQL 的同时，对 SQL 的所有命令都有对其进行进一层封装，例如条件语句、连接查询、排序、分组、Limit 等，同时它扩展了同时多个插入更新、Exists、悲观锁等功能。使用查询构造器查询出来的数据记录为 Laravel 特有的集合类型，Larvel 为集合类型封装了很多简便快捷的数据处理方法 API，例如 map（遍历）、filter（过滤）、diff（比较）、forPage（快速分页）、groupBy（快速分组）等等。事务处理Laravel 框架对 Mysql 的事务处理进行了有效方便的封装，可以让我们对数据库进行开启事务处理功能。开启事务，可以有效地防止数据库方式死锁。在本在线考试系统中，教师可以对正在创建的考试进行临时保存，在进行重新编辑并重新保存时，需要先删除当前该试卷已保存的试题记录，然后再插入修改后的试题记录。这时候在删除和插入的过程中，有可能会发生数据库数据未能正常删除，然后插入了相同 ID 记录，形成数据表错误或发生死锁。所有，我们可以对删除和插入构成同一个事务，只有当删除和插入都没异常时再进行事务提交，若有异常则进行回滚。使用 DB::beginTransaction()开启事务，然后把所有数据库操作放在一个 try 模块下，在 try 模块最后使用 DB::commit()进行事务提交，然后 catch 模块写入回滚代码 DB::rollBack()。本次研究中，项目中在学生提交考试、教师编辑临时保存考试、教师发布考试、教师编辑班级等模块操作中都有使用相应事务处理功能。响应体封装Response.phpclass Response extends Model{  public static function success() {    $result = array(      'code' => 200,      'message' => '操作成功'    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }  public static function successMsg($message = '') {    $result = array(      'code' => 200,      'message' => $message    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }  public static function successData(    $data = array(),    $message = '数据获取成功'  ) {    $result = array(      'code' => 200,      'message' => $message,      'data' => $data    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }  public static function successPage(    $items = array(),    $page = 1,    $pageSize = 10,    $total = 0,    $message='数据获取成功'  ) {    $result = array(      'code' => 200,      'message' => $message,      'data' => [        'items' => $items,        'page' => $page,        'pageSize' => $pageSize,        'total' => $total      ]    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }  public static function loginError() {    $result = array(      'code' => 300,      'message' => '登录状态异常'    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }  public static function parameterError() {    $result = array(      'code' => 301,      'message' => '参数错误'    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }  public static function error($code = 302 , $message = '') {    if(!is_numeric($code)) return;    $result = array(      'code' => $code,      'message' => $message    );    echo json_encode($result, JSON_UNESCAPED_UNICODE);    exit;  }}前端界面截图登录界面创建考试成绩管理考试管理考试考试结果由于时间仓促，本次开发的系统虽然基本功能已经完成，但仍有很大的提升空间。以上内容未经授权请勿随意转载。系统在线访问：ExamSystem"}]